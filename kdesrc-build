#!/usr/bin/env perl

# Script to handle building KDE from source code.  All of the configuration is
# stored in the file ~/.kdesrc-buildrc.
#
# Please also see the documentation that should be included with this program,
# in the doc/ directory.
#
# Copyright © 2003 - 2012 Michael Pyne. <mpyne@kde.org>
# Home page: http://kdesrc-build.kde.org/
#
# Copyright © 2005, 2006, 2008 - 2011 David Faure <faure@kde.org>
# Copyright © 2005 Thiago Macieira <thiago@kde.org>
# Copyright © 2006 Stephan Kulow <coolo@kde.org>
# Copyright © 2006, 2008 Dirk Mueller <mueller@kde.org>
# ... and possibly others. Check the git source repository for specifics.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

# Adding an option? Grep for 'defaultGlobalOptions' --mpyne

use FindBin qw($RealBin);
use lib "$RealBin/../share/apps/kdesrc-build/modules";
use lib "$RealBin/modules";

# Force all symbols to be in this package. We can tell if we're being called
# through require/eval/etc. by using the "caller" function.
package main;

use strict;
use warnings;
use Fcntl qw(:DEFAULT :seek);    # For sysopen constants
use Carp;
use POSIX qw(strftime :sys_wait_h _exit);
use File::Basename; # basename
use File::Find; # For our lndir reimplementation.
use File::Path qw(remove_tree);
use File::Glob ':glob';
use File::Spec;     # tmpdir, rel2abs
use File::Temp qw(tempfile);
use LWP::UserAgent;
use URI; # For git-clone snapshot support
use Sys::Hostname;
use Storable 'dclone';
use IO::Handle;
use Data::Dumper;

use ksb::IPC;
use ksb::Debug;
use ksb::Util;
use ksb::Version qw(scriptVersion);
use ksb::IPC::Pipe;
use ksb::IPC::Null;
use ksb::KDEXMLReader;
use ksb::Updater::Git;
use ksb::Module;

use 5.010_000; # Require Perl 5.10.0

# Make Perl 'plain die' exceptions use Carp::confess instead of their core
# support. This is not supported by the Perl 5 authors but assuming it works
# will be better than the alternative backtrace we get (which is to say, none)
$SIG{__DIE__} = \&Carp::confess;

# packages {{{

# global variables {{{

use constant {
    # We use a named remote to make some git commands work that don't accept the
    # full path.
    KDE_PROJECT_ID   => 'kde-projects',          # git-repository-base for kde_projects.xml
};

my $SCRIPT_VERSION = scriptVersion();

# This is a hash since Perl doesn't have a "in" keyword.
my %ignore_list;  # List of packages to refuse to include in the build list.

my $run_mode = 'build'; # Determines if updating, building, installing, etc.

# }}}

# package ksb::BuildContext {{{
{
    # This contains the information needed about the build context, e.g.
    # list of modules, what phases each module is in, the various options,
    # etc.
    package ksb::BuildContext;

    use Carp 'confess';
    use File::Basename; # dirname
    use IO::File;
    use POSIX qw(strftime);
    use Errno qw(:POSIX);

    use ksb::Debug;
    use ksb::Util;
    use ksb::PhaseList;
    use ksb::Module;

    # We derive from ksb::Module so that BuildContext acts like the 'global'
    # ksb::Module, with some extra functionality.
    our @ISA = qw(ksb::Module);

    my @DefaultPhases = qw/update build install/;
    my @rcfiles = ("./kdesrc-buildrc", "$ENV{HOME}/.kdesrc-buildrc");
    my $LOCKFILE_NAME = '.kdesrc-lock';

    # The # will be replaced by the directory the rc File is stored in.
    my $PERSISTENT_FILE_NAME = '#/.kdesrc-build-data';

    # defaultGlobalOptions {{{
    my %defaultGlobalOptions = (
        "async"                => 1,
        "binpath"              => '',
        "branch"               => "",
        "build-dir"            => "build",
        "build-system-only"    => "",
        "build-when-unchanged" => 1, # Safe default
        "checkout-only"        => "",
        "cmake-options"        => "",
        "colorful-output"      => 1, # Use color by default.
        "configure-flags"      => "",
        "custom-build-command" => '',
        "cxxflags"             => "-pipe",
        "debug"                => "",
        "debug-level"          => ksb::Debug::INFO,
        "delete-my-patches"    => 0, # Should only be set from cmdline
        "delete-my-settings"   => 0, # Should only be set from cmdline
        "dest-dir"             => '${MODULE}', # single quotes used on purpose!
        "disable-agent-check"  => 0,   # If true we don't check on ssh-agent
        "do-not-compile"       => "",
        "git-desired-protocol" => 'git', # protocol to grab from kde-projects
        "git-repository-base"  => {}, # Base path template for use multiple times.
        "http-proxy"           => '', # Proxy server to use for HTTP.
        "install-after-build"  => 1,  # Default to true
        "install-session-driver" => 1,# Default to true
        "kdedir"               => "$ENV{HOME}/kde",
        "kde-languages"        => "",
        "libpath"              => "",
        "log-dir"              => "log",
        "make-install-prefix"  => "",  # Some people need sudo
        "make-options"         => "",
        "manual-build"         => "",
        "manual-update"        => "",
        "module-base-path"     => "",  # Used for tags and branches
        "niceness"             => "10",
        "no-svn"               => "",
        "override-build-system"=> "",
        "override-url"         => "",
        "persistent-data-file" => "",
        "prefix"               => "", # Override installation prefix.
        "pretend"              => "",
        "purge-old-logs"       => 1,
        "qtdir"                => "$ENV{HOME}/qt4",
        "reconfigure"          => "",
        "refresh-build"        => "",
        "remove-after-install" => "none", # { none, builddir, all }
        "repository"           => '',     # module's git repo
        "revision"             => 0,
        "run-tests"            => 0,  # 1 = make test, upload = make Experimental
        "set-env"              => { }, # Hash of environment vars to set
        "source-dir"           => "$ENV{HOME}/kdesrc",
        "ssh-identity-file"    => '', # If set, is passed to ssh-add.
        "stop-on-failure"      => "",
        "svn-server"           => "svn://anonsvn.kde.org/home/kde",
        "tag"                  => "",
        "use-clean-install"    => 0,
        "use-idle-io-priority" => 0,
        "use-modules"          => "",
        # Controls whether to build "stable" branches instead of "master"
        "use-stable-kde"       => 0,
    );
    # }}} 1

    sub new
    {
        my ($class, @args) = @_;

        # It is very important to use the ksb::Module:: syntax instead of ksb::Module->,
        # otherwise you can't pass $class and have it used as the classname.
        my $self = ksb::Module::new($class, undef, 'global');
        my %newOpts = (
            modules => [],
            context => $self, # Fix link to buildContext (i.e. $self)
            build_options => {
                global => \%defaultGlobalOptions,
                # Module options are stored under here as well, keyed by module->name()
            },
            # This one replaces ksb::Module::{phases}
            phases  => ksb::PhaseList->new(@DefaultPhases),
            errors  => {
                # Phase names from phases map to a references to a list of failed Modules
                # from that phase.
            },
            logPaths=> {
                # Holds a hash table of log path bases as expanded by
                # getSubdirPath (e.g. [source-dir]/log) to the actual log dir
                # *this run*, with the date and unique id added. You must still
                # add the module name to use.
            },
            rcFiles => [@rcfiles],
            rcFile  => undef,
            env     => { },
            ignore_list => [ ], # List of XML paths to ignore completely.
        );

        # Merge all new options into our self-hash.
        @{$self}{keys %newOpts} = values %newOpts;
        $self->{options} = $self->{build_options}{global};

        assert_isa($self, 'ksb::Module');
        assert_isa($self, 'ksb::BuildContext');

        return $self;
    }

    # Gets the ksb::PhaseList for this context, and optionally sets it first to
    # the ksb::PhaseList passed in.
    sub phases
    {
        my ($self, $phases) = @_;

        if ($phases) {
            confess("Invalid type, expected PhaseList")
                unless $phases->isa('ksb::PhaseList');
            $self->{phases} = $phases;
        }
        return $self->{phases};
    }

    sub addModule
    {
        my ($self, $module) = @_;
        Carp::confess("No module to push") unless $module;

        if (list_has($self->{modules}, $module)) {
            debug("Skipping duplicate module ", $module->name());
        }
        elsif ($module->getOption('#xml-full-path') &&
               list_has($self->{ignore_list}, $module->getOption('#xml-full-path')))
        {
            debug("Skipping ignored module $module");
        }
        else {
            debug("Adding ", $module->name(), " to module list");
            push @{$self->{modules}}, $module;
        }
    }

    sub moduleList
    {
        my $self = shift;
        return $self->{modules};
    }

    # Sets a list of modules to ignore processing on completely.
    # Parameters should simply be a list of XML repository paths to ignore,
    # e.g. 'extragear/utils/kdesrc-build'.
    sub setIgnoreList
    {
        my $self = shift;
        $self->{ignore_list} = [@_];

        debug ("Set context ignore list to ", join(', ', @_));
    }

    sub setupOperatingEnvironment
    {
        my $self = shift;
        # Set the process priority
        POSIX::nice(int $self->getOption('niceness'));

        # Set the IO priority if available.
        if ($self->getOption('use-idle-io-priority')) {
            # -p $$ is our PID, -c3 is idle priority
            # 0 return value means success
            if (safe_system('ionice', '-c3', '-p', $$) != 0) {
                warning (" b[y[*] Unable to lower I/O priority, continuing...");
            }
        }

        # Get ready for logged output.
        ksb::Debug::setLogFile($self->getLogDirFor($self) . '/build-log');

        # Propagate HTTP proxy through environment unless overridden.
        if ((my $proxy = $self->getOption('http-proxy')) &&
            !defined $ENV{'http_proxy'})
        {
            $self->queueEnvironmentVariable('http_proxy', $proxy);
        }
    }

    # Clears the list of environment variables to set for log_command runs.
    sub resetEnvironment
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');

        $self->{env} = { };
    }

    # Adds an environment variable and value to the list of environment
    # variables to apply for the next subprocess execution.
    #
    # Note that these changes are /not/ reflected in the current environment,
    # so if you are doing something that requires that kind of update you
    # should do that yourself (but remember to have some way to restore the old
    # value if necessary).
    #
    # In order to keep compatibility with the old 'setenv' sub, no action is
    # taken if the value is not equivalent to boolean true.
    sub queueEnvironmentVariable
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');
        my ($key, $value) = @_;

        return unless $value;

        debug ("\tQueueing g[$key] to be set to y[$value]");
        $self->{env}->{$key} = $value;
    }

    # Applies all changes queued by queueEnvironmentVariable to the actual
    # environment irretrievably. Use this before exec()'ing another child, for
    # instance.
    sub commitEnvironmentChanges
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');

        while (my ($key, $value) = each %{$self->{env}}) {
            $ENV{$key} = $value;
            debug ("\tSetting environment variable g[$key] to g[b[$value]");
        }
    }

    # Adds the given library paths to the path already given in an environment
    # variable. In addition, detected "system paths" are stripped to ensure
    # that we don't inadvertently re-add a system path to be promoted over the
    # custom code we're compiling (for instance, when a system Qt is used and
    # installed to /usr).
    #
    # If the environment variable to be modified has already been queued using
    # queueEnvironmentVariable, then that (queued) value will be modified and
    # will take effect with the next forked subprocess.
    #
    # Otherwise, the current environment variable value will be used, and then
    # queued. Either way the current environment will be unmodified afterward.
    #
    # First parameter is the name of the environment variable to modify
    # All remaining paramters are prepended to the current environment path, in
    # the order given. (i.e. param1, param2, param3 ->
    # param1:param2:param3:existing)
    sub prependEnvironmentValue
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');
        my ($envName, @items) = @_;
        my @curPaths = split(':', $self->{env}->{$envName} // $ENV{$envName} // '');

        # Filter out entries to add that are already in the environment from
        # the system.
        for my $path (grep { list_has(\@curPaths, $_) } (@items) ) {
            debug ("\tNot prepending y[$path] to y[$envName] as it appears " .
                  "to already be defined in y[$envName].");
        }

        @items = grep { not list_has(\@curPaths, $_); } (@items);

        my $envValue = join(':', @items, @curPaths);

        $envValue =~ s/^:*//;
        $envValue =~ s/:*$//; # Remove leading/trailing colons
        $envValue =~ s/:+/:/; # Remove duplicate colons

        $self->queueEnvironmentVariable($envName, $envValue);
    }

    # Installs the given subroutine as a signal handler for a set of signals which
    # could kill the program.
    #
    # First parameter is a reference to the sub to act as the handler.
    sub installSignalHandlers
    {
        my $handlerRef = shift;
        my @signals = qw/HUP INT QUIT ABRT TERM PIPE/;

        @SIG{@signals} = ($handlerRef) x scalar @signals;
    }

    # Tries to take the lock for our current base directory, which currently is
    # what passes for preventing people from accidentally running kdesrc-build
    # multiple times at once.  The lock is based on the base directory instead
    # of being global to allow for motivated and/or brave users to properly
    # configure kdesrc-build to run simultaneously with different
    # configurations.
    #
    # Return value is a boolean success flag.
    sub takeLock
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');
        my $baseDir = $self->baseConfigDirectory();
        my $lockfile = "$baseDir/$LOCKFILE_NAME";

        $! = 0; # Force reset to non-error status
        sysopen LOCKFILE, $lockfile, O_WRONLY | O_CREAT | O_EXCL;
        my $errorCode = $!; # Save for later testing.

        # Install signal handlers to ensure that the lockfile gets closed.
        # There is a race condition here, but at worst we have a stale lock
        # file, so I'm not *too* concerned.
        installSignalHandlers(sub {
            note ("Signal received, terminating.");
            @main::atexit_subs = (); # Remove their finish, doin' it manually
            main::finish($self, 5);
        });

        if ($errorCode == EEXIST)
        {
            # Path already exists, read the PID and see if it belongs to a
            # running process.
            open (my $pidFile, "<", $lockfile) or do
            {
                # Lockfile is there but we can't open it?!?  Maybe a race
                # condition but I have to give up somewhere.
                warning (" WARNING: Can't open or create lockfile r[$lockfile]");
                return 1;
            };

            my $pid = <$pidFile>;
            close $pidFile;

            if ($pid)
            {
                # Recent kdesrc-build; we wrote a PID in there.
                chomp $pid;

                # See if something's running with this PID.
                if (kill(0, $pid) == 1)
                {
                    # Something *is* running, likely kdesrc-build.  Don't use error,
                    # it'll scan for $!
                    print ksb::Debug::colorize(" r[*y[*r[*] kdesrc-build appears to be running.  Do you want to:\n");
                    print ksb::Debug::colorize("  (b[Q])uit, (b[P])roceed anyways?: ");

                    my $choice = <STDIN>;
                    chomp $choice;

                    if (lc $choice ne 'p')
                    {
                        say ksb::Debug::colorize(" y[*] kdesrc-build run canceled.");
                        return 0;
                    }

                    # We still can't grab the lockfile, let's just hope things
                    # work out.
                    note (" y[*] kdesrc-build run in progress by user request.");
                    return 1;
                }

                # If we get here, then the program isn't running (or at least not
                # as the current user), so allow the flow of execution to fall
                # through below and unlink the lockfile.
            } # pid

            # No pid found, optimistically assume the user isn't running
            # twice.
            warning (" y[WARNING]: stale kdesrc-build lockfile found, deleting.");
            unlink $lockfile;

            sysopen (LOCKFILE, $lockfile, O_WRONLY | O_CREAT | O_EXCL) or do {
                error (" r[*] Still unable to lock $lockfile, proceeding anyways...");
                return 1;
            };

            # Hope the sysopen worked... fall-through
        }
        elsif ($errorCode == ENOTTY)
        {
            # Stupid bugs... normally sysopen will return ENOTTY, not sure who's to blame between
            # glibc and Perl but I know that setting PERLIO=:stdio in the environment "fixes" things.
            ; # pass
        }
        elsif ($errorCode != 0) # Some other error occurred.
        {
            warning (" r[*]: Error $errorCode while creating lock file (is $baseDir available?)");
            warning (" r[*]: Continuing the script for now...");

            # Even if we fail it's generally better to allow the script to proceed
            # without being a jerk about things, especially as more non-CLI-skilled
            # users start using kdesrc-build to build KDE.
            return 1;
        }

        say LOCKFILE "$$";
        close LOCKFILE;

        return 1;
    }

    # Releases the lock obtained by takeLock.
    sub closeLock
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');
        my $baseDir = $self->baseConfigDirectory();
        my $lockFile = "$baseDir/$LOCKFILE_NAME";

        unlink ($lockFile) or warning(" y[*] Failed to close lock: $!");
    }

    # This subroutine accepts a Module parameter, and returns the log directory
    # for it. You can also pass a BuildContext (including this one) to get the
    # default log directory.
    #
    # As part of setting up what path to use for the log directory, the
    # 'latest' symlink will also be setup to point to the returned log
    # directory.
    sub getLogDirFor
    {
        my ($self, $module) = @_;

        my $baseLogPath = $module->getSubdirPath('log-dir');
        my $logDir;

        if (!exists $self->{logPaths}{$baseLogPath}) {
            # No log dir made for this base, do so now.
            my $id = '01';
            my $date = strftime "%F", localtime; # ISO 8601 date
            $id++ while -e "$baseLogPath/$date-$id";
            $self->{logPaths}{$baseLogPath} = "$baseLogPath/$date-$id";
        }

        $logDir = $self->{logPaths}{$baseLogPath};
        return $logDir if pretending();

        super_mkdir($logDir) unless -e $logDir;

        # No symlink munging or module-name-adding is needed for the default
        # log dir.
        return $logDir if $module->isa('ksb::BuildContext');

        # Add a symlink to the latest run for this module.  'latest' itself is
        # a directory under the default log directory that holds module
        # symlinks, pointing to the last log directory run for that module.  We
        # do need to be careful of modules that have multiple directory names
        # though (like extragear/foo).

        my $latestPath = "$baseLogPath/latest";

        # Handle stuff like playground/utils or KDE/kdelibs
        my ($moduleName, $modulePath) = fileparse($module->name());
        $latestPath .= "/$modulePath" if $module->name() =~ m(/);

        super_mkdir($latestPath);

        my $symlinkTarget = "$logDir/$moduleName";
        my $symlink = "$latestPath/$moduleName";

        if (-l $symlink and readlink($symlink) ne $symlinkTarget)
        {
            unlink($symlink);
            symlink($symlinkTarget, $symlink);
        }
        elsif(not -e $symlink)
        {
            # Create symlink initially if we've never done it before.
            symlink($symlinkTarget, $symlink);
        }

        super_mkdir($symlinkTarget);
        return $symlinkTarget;
    }

    # Returns rc file in use. Call loadRcFile first.
    sub rcFile
    {
        my $self = shift;
        return $self->{rcFile};
    }

    # Forces the rc file to be read from to be that given by the first
    # parameter.
    sub setRcFile
    {
        my ($self, $file) = @_;
        $self->{rcFiles} = [$file];
        $self->{rcFile} = undef;
    }

    # Returns an open filehandle to the user's chosen rc file.  Use setRcFile
    # to choose a file to load before calling this function, otherwise
    # loadRcFile will search the default search path.  After this function is
    # called, rcFile() can be used to determine which file was loaded.
    #
    # If unable to find or open the rc file an exception is raised. Empty rc
    # files are supported however.
    #
    # TODO: Support a fallback default rc file.
    sub loadRcFile
    {
        my $self = shift;
        my @rcFiles = @{$self->{rcFiles}};
        my $fh;

        for my $file (@rcFiles)
        {
            if (open ($fh, '<', "$file"))
            {
                $self->{rcFile} = File::Spec->rel2abs($file);
                return $fh;
            }
        }

        # No rc found, check if we can use default.
        if (scalar @rcFiles == 1)
        {
            # This can only happen if the user uses --rc-file, so if we fail to
            # load the file, we need to fail to load at all.
            my $failedFile = $rcFiles[0];

            error (<<EOM);
Unable to open config file $failedFile

Script stopping here since you specified --rc-file on the command line to
load $failedFile manually.  If you wish to run the script with no configuration
file, leave the --rc-file option out of the command line.

If you want to force an empty rc file, use --rc-file /dev/null

EOM
            croak_runtime("Missing $failedFile");
        }

        # Set rcfile to something so the user knows what file to edit to
        # get what they want to work.

        # Our default is to use a kdesrc-buildrc-sample if present in the same
        # directory.
        my $basePath = dirname($0);
        my $sampleConfigFile = "$basePath/kdesrc-buildrc-sample";
        open ($fh, '<', $sampleConfigFile)
            or croak_runtime("No configuration available");

        $self->{rcFile} = $sampleConfigFile;
        $self->{rcFile} =~ s,^$ENV{HOME}/,~/,;
        note (" * Using included sample configuration.");

        return $fh;
    }

    # Returns the base directory that holds the configuration file. This is
    # typically used as the directory base for other necessary kdesrc-build
    # execution files, such as the persistent data store and lock file.
    #
    # The RC file must have been found and loaded first, obviously.
    sub baseConfigDirectory
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');
        my $rcfile = $self->rcFile() or
            croak_internal("Call to baseConfigDirectory before loadRcFile");

        return dirname($rcfile);
    }

    sub modulesInPhase
    {
        my ($self, $phase) = @_;
        my @list = grep { list_has([$_->phases()->phases()], $phase) } (@{$self->moduleList()});
        return @list;
    }

    # Searches for a module with a name that matches the provided parameter,
    # and returns its ksb::Module object. Returns undef if no match was found.
    # As a special-case, returns the BuildContext itself if the name passed is
    # 'global', since the BuildContext also is a (in the "is-a" OOP sense)
    # ksb::Module, specifically the 'global' one.
    sub lookupModule
    {
        my ($self, $moduleName) = @_;

        return $self if $moduleName eq 'global';

        my @options = grep { $_->name() eq $moduleName } (@{$self->moduleList()});
        return undef unless @options;

        if (scalar @options > 1) {
            croak_internal("Detected 2 or more $moduleName ksb::Module objects");
        }

        return $options[0];
    }

    sub markModulePhaseFailed
    {
        my ($self, $phase, $module) = @_;
        assert_isa($module, 'ksb::Module');

        # Make a default empty list if we haven't already marked a module in this phase as
        # failed.
        $self->{errors}{$phase} //= [ ];
        push @{$self->{errors}{$phase}}, $module;
    }

    # Returns a list (i.e. not a reference to, but a real list) of Modules that failed to
    # complete the given phase.
    sub failedModulesInPhase
    {
        my ($self, $phase) = @_;

        # The || [] expands an empty array if we had no failures in the given phase.
        return @{$self->{errors}{$phase} || []};
    }

    # Returns true if the build context has overridden the value of the given module
    # option key. Use getOption (on this object!) to get what the value actually is.
    sub hasStickyOption
    {
        my ($self, $key) = @_;
        $key =~ s/^#//; # Remove sticky marker.

        return 1 if list_has([qw/pretend disable-agent-check/], $key);
        return $self->hasOption("#$key");
    }

    # OVERRIDE: Returns one of the following:
    # 1. The sticky option overriding the option name given.
    # 2. The value of the option name given.
    # 3. The empty string (this function never returns undef).
    #
    # The first matching option is returned. See ksb::Module::getOption, which is
    # typically what you should be using.
    sub getOption
    {
        my ($self, $key) = @_;

        foreach ("#$key", $key) {
            return $self->{options}{$_} if exists $self->{options}{$_};
        }

        return '';
    }

    # OVERRIDE: Overrides ksb::Module::setOption to handle some global-only options.
    sub setOption
    {
        my ($self, %options) = @_;

        # Actually set options.
        $self->SUPER::setOption(%options);

        # Automatically respond to various global option changes.
        while (my ($key, $value) = each %options) {
            my $normalizedKey = $key;
            $normalizedKey =~ s/^#//; # Remove sticky key modifier.
            given ($normalizedKey) {
                when ('colorful-output') { ksb::Debug::setColorfulOutput($value); }
                when ('debug-level')     { ksb::Debug::setDebugLevel($value); }
                when ('pretend')         { ksb::Debug::setPretending($value); }
            }
        }
    }

    #
    # Persistent option handling
    #

    # Returns the name of the file to use for persistent data.
    # Supports expanding '#' at the beginning of the filename to the directory
    # containing the rc-file in use, but only for the default name at this
    # point.
    sub persistentOptionFileName
    {
        my $self = shift;
        my $filename = $self->getOption('persistent-data-file');

        if (!$filename) {
            $filename = $PERSISTENT_FILE_NAME;
            my $dir = $self->baseConfigDirectory();
            $filename =~ s/^#/$dir/;
        }
        else {
            # Tilde-expand
            $filename =~ s/^~\//$ENV{HOME}\//;
        }

        return $filename;
    }

    # Reads in all persistent options from the file where they are kept
    # (.kdesrc-build-data) for use in the program.
    #
    # The directory used is the same directory that contains the rc file in use.
    sub loadPersistentOptions
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');
        my $fh = IO::File->new($self->persistentOptionFileName(), '<');

        return unless $fh;

        my $persistent_data;
        {
            local $/ = undef; # Read in whole file with <> operator.
            $persistent_data = <$fh>;
        }

        # $persistent_data should be Perl code which, when evaluated will give us
        # a hash called persistent_options which we can then merge into our
        # persistent options.

        my $persistent_options;

        # eval must appear after declaration of $persistent_options
        eval $persistent_data;
        if ($@)
        {
            # Failed.
            error ("Failed to read persistent module data: r[b[$@]");
            return;
        }

        # We need to keep persistent data with the context instead of with the
        # applicable modules since otherwise we might forget to write out
        # persistent data for modules we didn't build in this run. So, we just
        # store it all.
        # Layout of this data:
        #  $self->persistent_options = {
        #    'module-name' => {
        #      option => value,
        #      # foreach option/value pair
        #    },
        #    # foreach module
        #  }
        $persistent_options = {} if ref $persistent_options ne 'HASH';
        $self->{persistent_options} = $persistent_options;
    }

    # Writes out the persistent options to the file .kdesrc-build-data.
    #
    # The directory used is the same directory that contains the rc file in use.
    sub storePersistentOptions
    {
        my $self = assert_isa(shift, 'ksb::BuildContext');
        return if pretending();

        my $fh = IO::File->new($self->persistentOptionFileName(), '>');

        if (!$fh)
        {
            error ("Unable to save persistent module data: b[r[$!]");
            return;
        }

        print $fh "# AUTOGENERATED BY kdesrc-build $SCRIPT_VERSION\n";

        $Data::Dumper::Indent = 1;
        print $fh Data::Dumper->Dump([$self->{persistent_options}], ["persistent_options"]);
        undef $fh; # Closes the file
    }

    # Returns the value of a "persistent" option (normally read in as part of
    # startup), or undef if there is no value stored.
    #
    # First parameter is the module name to get the option for, or 'global' if
    # not for a module.
    #     Note that unlike setOption/getOption, no inheritance is done at this
    #     point so if an option is present globally but not for a module you
    #     must check both if that's what you want.
    # Second parameter is the name of the value to retrieve (i.e. the key)
    sub getPersistentOption
    {
        my ($self, $moduleName, $key) = @_;
        my $persistent_opts = $self->{persistent_options};

        # We must check at each level of indirection to avoid
        # "autovivification"
        return unless exists $persistent_opts->{$moduleName};
        return unless exists $persistent_opts->{$moduleName}{$key};

        return $persistent_opts->{$moduleName}{$key};
    }

    # Clears a persistent option if set (for a given module and option-name).
    #
    # First parameter is the module name to get the option for, or 'global' for
    # the global options.
    # Second parameter is the name of the value to clear.
    # No return value.
    sub unsetPersistentOption
    {
        my ($self, $moduleName, $key) = @_;
        my $persistent_opts = $self->{persistent_options};

        if (exists $persistent_opts->{$moduleName} &&
            exists $persistent_opts->{$moduleName}->{$key})
        {
            delete $persistent_opts->{$moduleName}->{$key};
        }
    }

    # Sets a "persistent" option which will be read in for a module when
    # kdesrc-build starts up and written back out at (normal) program exit.
    #
    # First parameter is the module name to set the option for, or 'global'.
    # Second parameter is the name of the value to set (i.e. key)
    # Third parameter is the value to store, which must be a scalar.
    sub setPersistentOption
    {
        my ($self, $moduleName, $key, $value) = @_;
        my $persistent_opts = $self->{persistent_options};

        # Initialize empty hash ref if nothing defined for this module.
        $persistent_opts->{$moduleName} //= { };

        $persistent_opts->{$moduleName}{$key} = $value;
    }

    1;
}
# }}}

# package RecursiveFH {{{
{
    package RecursiveFH;

    # Alias the global make_exception into this package.
    *make_exception = *main::make_exception;

    sub new
    {
        my ($class) = @_;
        my $data = {
            'filehandles' => [],    # Stack of filehandles to read
            'current'     => undef, # Current filehandle to read
        };

        return bless($data, $class);
    }

    sub addFilehandle
    {
        my ($self, $fh) = @_;
        push @{$self->{filehandles}}, $fh;
        $self->setCurrentFilehandle($fh);
    }

    sub popFilehandle
    {
        my $self = shift;
        my $result = pop @{$self->{filehandles}};
        my $newFh = scalar @{$self->{filehandles}} ? ${$self->{filehandles}}[-1]
                                                   : undef;
        $self->setCurrentFilehandle($newFh);
        return $result;
    }

    sub currentFilehandle
    {
        my $self = shift;
        return $self->{current};
    }

    sub setCurrentFilehandle
    {
        my $self = shift;
        $self->{current} = shift;
    }

    # Reads the next line of input and returns it.
    # If a line of the form "include foo" is read, this function automatically
    # opens the given file and starts reading from it instead. The original
    # file is not read again until the entire included file has been read. This
    # works recursively as necessary.
    #
    # No further modification is performed to returned lines.
    #
    # undef is returned on end-of-file (but only of the initial filehandle, not
    # included files from there)
    sub readLine
    {
        my $self = shift;

        # Starts a loop so we can use evil things like "redo"
        READLINE: {
            my $line;
            my $fh = $self->currentFilehandle();

            # Sanity check since different methods might try to read same file reader
            return undef unless defined $fh;

            if (eof($fh) || !defined($line = <$fh>)) {
                my $oldFh = $self->popFilehandle();
                close $oldFh;

                my $fh = $self->currentFilehandle();

                return undef if !defined($fh);

                redo READLINE;
            }
            elsif ($line =~ /^\s*include\s+\S/) {
                # Include found, extract file name and open file.
                chomp $line;
                my ($filename) = ($line =~ /^\s*include\s+(.+)$/);

                if (!$filename) {
                    die make_exception('Config',
                        "Unable to handle file include on line $., '$line'");
                }

                my $newFh;
                $filename =~ s/^~\//$ENV{HOME}\//; # Tilde-expand

                open ($newFh, '<', $filename) or
                    die make_exception('Config',
                        "Unable to open file $filename which was included from line $.");

                $self->addFilehandle($newFh);

                redo READLINE;
            }
            else {
                return $line;
            }
        }
    }

    1;
}
# }}}

# package DependencyResolver {{{
{
    package DependencyResolver;

    # This module handles resolving dependencies between modules. Each "module"
    # from the perspective of this resolver is simply a module full name, as
    # given by the KDE Project database.  (e.g. extragear/utils/kdesrc-build)

    use ksb::Debug;
    use ksb::Util;
    use List::Util qw(first);

    sub new
    {
        my $class = shift;

        my $self = {
            # hash table mapping full module names (m) to a list reference
            # containing the full module names of modules that depend on m.
            dependenciesOf  => { },
        };

        return bless $self, $class;
    }

    # Reads in dependency data in a psuedo-Makefile format.
    # See kde-build-metadata/dependency-data.
    #
    # Object method.
    # First parameter is the filehandle to read from.
    sub readDependencyData
    {
        my $self = assert_isa(shift, 'DependencyResolver');
        my $fh = shift;

        my $dependenciesOfRef  = $self->{dependenciesOf};
        my $dependencyAtom =
            qr/
            ^\s*        # Clear leading whitespace
            ([^\[:\s]+) # (1) Capture anything not a [, :, or whitespace (dependent item)
            \s*         # Clear whitespace we didn't capture
            (?:\[       # Open a non-capture group...
                ([^\]:\s]+) # (2) Capture branch name without brackets
            ])?+        # Close group, make optional, no backtracking
            \s*         # Clear whitespace we didn't capture
            :
            \s*
            ([^\s\[]+)  # (3) Capture all non-whitespace (source item)
            (?:\s*\[     # Open a non-capture group...
                ([^\]\s]+) # (4) Capture branch name without brackets
            ])?+        # Close group, make optional, no backtracking
            \s*$        # Ensure no trailing cruft. Any whitespace should end line
            /x;         # /x Enables extended whitespace mode

        while(my $line = <$fh>) {
            # Strip comments, skip empty lines.
            $line =~ s{#.*$}{};
            next if $line =~ /^\s*$/;

            if ($line !~ $dependencyAtom) {
                croak_internal("Invalid line $line when reading dependency data.");
            }

            my ($dependentItem, $dependentBranch,
                $sourceItem,    $sourceBranch) = $line =~ $dependencyAtom;

            # Ignore "doesn't use" markers.
            next if index($sourceItem, '-') == 0;

            # Ignore "catch-all" dependencies.
            next if $sourceItem =~ m,/\*$, || $dependentItem =~ m,/\*$,;

            # Ignore deps on Qt, since we allow system Qt.
            next if $sourceItem =~ /^\s*Qt/ || $dependentItem =~ /^\s*Qt/;

            # TODO: Utilize branch information in dependency tracking.
            if ($dependentBranch || $sourceBranch) {
                ksb::Debug::whisper ("$dependentItem only partially depends on $sourceItem");
                next;
            }

            # Initialize with array if not already defined.
            $dependenciesOfRef->{$dependentItem} //= [ ];

            push @{$dependenciesOfRef->{$dependentItem}}, $sourceItem;
        }
    }

    # Internal.
    # This method adds any full module names as dependencies of any module that
    # begins with that full module name. E.g. kde/kdelibs/foo automatically
    # depends on kde/kdelibs if both are present in the build.
    #
    # Static method.
    # First parameter: Reference to a hash of parameters.
    # Return: Nothing.
    sub _addInherentDependencies
    {
        my $optionsRef = shift;
        my $dependenciesOfRef   = $optionsRef->{dependenciesOf};
        my $modulesFromNameRef  = $optionsRef->{modulesFromName};

        # It's not good enough to just sort modules and compare one to its
        # successor. Consider kde/foo, kde/foobar, kde/foo/a. The dependency
        # here would be missed that way. Instead we strip off the last path
        # component and see if that matches an existing module name.
        for my $testModule (keys %{$modulesFromNameRef}) {
            my $candidateBaseModule = $testModule;

            # Remove trailing component, bail if unable to do so.
            next unless $candidateBaseModule =~ s(/[^/]+$)();

            if ($candidateBaseModule &&
                exists $modulesFromNameRef->{$candidateBaseModule})
            {
                # Add candidateBaseModule as dependency of testModule.
                $dependenciesOfRef->{$testModule} //= [ ];

                my $moduleDepsRef = $dependenciesOfRef->{$testModule};
                if (!first { $_ eq $candidateBaseModule } @{$moduleDepsRef}) {
                    debug ("dep-resolv: Adding $testModule as dependency of $candidateBaseModule");
                    push @{$moduleDepsRef}, $candidateBaseModule;
                }
            }
        }
    }

    # Internal.
    # This method is used to topographically sort dependency data. It accepts
    # a ksb::Module, ensures that any KDE Projects it depends on are already on the
    # build list, and then adds the ksb::Module to the build list (whether it is
    # a KDE Project or not, to preserve ordering).
    #
    # Static method.
    # First parameter: Reference to a hash of parameters.
    # Second parameter: ksb::Module to "visit". Does not have to be a KDE Project.
    # Return: Nothing.
    sub _visitModuleAndDependencies
    {
        my ($optionsRef, $module) = @_;
        assert_isa($module, 'ksb::Module');

        my $visitedItemsRef     = $optionsRef->{visitedItems};
        my $properBuildOrderRef = $optionsRef->{properBuildOrder};
        my $dependenciesOfRef   = $optionsRef->{dependenciesOf};
        my $modulesFromNameRef  = $optionsRef->{modulesFromName};

        my $item = $module->getOption('#xml-full-path');

        if (!$item) {
            push @{$properBuildOrderRef}, $module;
            return;
        }

        debug ("dep-resolv: Visiting $item");

        $visitedItemsRef->{$item} //= 0;

        # This module may have already been added to build.
        return if $visitedItemsRef->{$item} == 1;

        # But if the value is 2 that means we've detected a cycle.
        if ($visitedItemsRef->{$item} > 1) {
            croak_internal("Somehow there is a dependency cycle involving $item! :(");
        }

        $visitedItemsRef->{$item} = 2; # Mark as currently-visiting for cycle detection.
        for my $subItem (@{$dependenciesOfRef->{$item}}) {
            debug ("\tdep-resolv: $item depends on $subItem");

            my $subModule = $modulesFromNameRef->{$subItem};
            if (!$subModule) {
                whisper (" y[b[*] $module depends on $subItem, but no module builds $subItem for this run.");
                next;
            }

            _visitModuleAndDependencies($optionsRef, $subModule);
        }

        $visitedItemsRef->{$item} = 1; # Mark as done visiting.
        push @{$properBuildOrderRef}, $module;
        return;
    }

    # This method takes a list of Modules (real ksb::Module objects, not just module
    # names).
    #
    # These modules have their dependencies resolved, and a new list of Modules
    # is returned, containing the proper build order for the module given.
    #
    # Only "KDE Project" modules can be re-ordered or otherwise affect the
    # build so this currently won't affect Subversion modules or "plain Git"
    # modules.
    #
    # The dependency data must have been read in first (readDependencyData).
    #
    # Object method
    # Parameters: Modules to evaluate, in suggested build order.
    # Return: Modules to build, with any KDE Project modules in a valid
    # ordering based on the currently-read dependency data.
    sub resolveDependencies
    {
        my $self = assert_isa(shift, 'DependencyResolver');
        my @modules = @_;

        my $optionsRef = {
            visitedItems => { },
            properBuildOrder => [ ],
            dependenciesOf => $self->{dependenciesOf},

            # will map names back to their Modules
            modulesFromName => {
                map { $_->getOption('#xml-full-path') => $_ } @modules
            },
        };

        # Adds things like kde/kdelibs/foo to automatically depend on
        # kde/kdelibs if both are present in the build.
        _addInherentDependencies($optionsRef);

        for my $module (@modules) {
            _visitModuleAndDependencies($optionsRef, $module);
        }

        return @{$optionsRef->{properBuildOrder}};
    }

    1;
}
# }}}

# }}}

# Moves the directory given by the first parameter to be at the directory given
# by the second parameter, but only if the first exists and the second doesn't.
# The use case is to automatically migrate source and build directories from
# the change in dest-dir handling for XML-based modules.
sub moveOldDirectories
{
    my ($oldDir, $newDir) = @_;
    state $pretendedMoves = { };

    # All this pretended move stuff is just to avoid tons of debug output
    # if run in pretend mode while still showing the message the first time.
    $pretendedMoves->{$oldDir} //= { };
    if (!$pretendedMoves->{$oldDir}->{$newDir} && -e $oldDir && ! -e $newDir) {
        info ("\tMoving old kdesrc-build directory at\n\t\tb[$oldDir] to\n\t\tb[$newDir]");

        $pretendedMoves->{$oldDir}->{$newDir} = 1 if pretending();
        safe_system('mv', $oldDir, $newDir) == 0 or
            croak_runtime("Unable to move directory $oldDir to $newDir");
    }

    return 1;
}

# Subroutine to return the directory that a module will be stored in.
# NOTE: The return value is a hash. The key 'module' will return the final
# module name, the key 'path' will return the full path to the module. The
# key 'fullpath' will return their concatenation.
# For example, with $module == 'KDE/kdelibs', and no change in the dest-dir
# option, you'd get something like:
# {
#   'path'     => '/home/user/kdesrc/KDE',
#   'module'   => 'kdelibs',
#   'fullpath' => '/home/user/kdesrc/KDE/kdelibs'
# }
# If dest-dir were changed to e.g. extragear-multimedia, you'd get:
# {
#   'path'     => '/home/user/kdesrc',
#   'module'   => 'extragear-multimedia',
#   'fullpath' => '/home/user/kdesrc/extragear-multimedia'
# }
# First parameter is the module.
# Second parameter is either source or build.
sub get_module_path_dir
{
    my $module = assert_isa(shift, 'ksb::Module');
    my $type = shift;
    my $destdir = $module->destDir();
    my $srcbase = $module->getSourceDir();
    $srcbase = $module->getSubdirPath('build-dir') if $type eq 'build';

    my $combined = "$srcbase/$destdir";

    # Remove dup //
    $combined =~ s/\/+/\//;

    my @parts = split(/\//, $combined);
    my %result = ();
    $result{'module'} = pop @parts;
    $result{'path'} = join('/', @parts);
    $result{'fullpath'} = "$result{path}/$result{module}";

    my $compatDestDir = $module->destDir($module->name());
    my $fullCompatPath = "$srcbase/$compatDestDir";

    # kdesrc-build 1.14 changed the source directory layout to be more
    # compatible with the sharply-growing number of modules.
    if ($fullCompatPath ne $combined && -d $fullCompatPath) {
        if ($type eq 'source') {
            super_mkdir($result{'path'});
            moveOldDirectories($fullCompatPath, $combined);
        }
        elsif ($type eq 'build') {
            # CMake doesn't like moving build directories, just destroy the
            # old one.
            state %warnedFor;

            if (!$warnedFor{$fullCompatPath}) {
                $warnedFor{$fullCompatPath} = 1;

                safe_rmtree($fullCompatPath) or do {
                    warning("\tUnable to remove the old build directory for y[b[$module]");
                    warning("\tThe disk layout has changed, you no longer need the old directory at");
                    warning("\t\tb[$fullCompatPath]");
                    warning("\tHowever you will have to delete it, kdesrc-build was unable to.");
                }
            };
        }
    }

    return %result;
}

# Subroutine to delete a directory and all files and subdirectories within.
# Does nothing in pretend mode.  An analogue to "rm -rf" from Linux.
# Requires File::Find module.
#
# First parameter: Path to delete
# Returns boolean true on success, boolean false for failure.
sub safe_rmtree
{
    my $path = shift;

    # Pretty user-visible path
    my $user_path = $path;
    $user_path =~ s/^$ENV{HOME}/~/;

    my $delete_file_or_dir = sub {
        # $_ is the filename/dirname.
        return if $_ eq '.' or $_ eq '..';
        if (-f $_ || -l $_)
        {
            unlink ($_) or croak_runtime("Unable to delete $File::Find::name: $!");
        }
        elsif (-d $_)
        {
            rmdir ($File::Find::name) or
                croak_runtime("Unable to remove directory $File::Find::name: $!");
        }
    };

    if (pretending())
    {
        pretend ("Would have removed all files/folders in $user_path");
        return 1;
    }

    # Error out because we probably have a logic error even though it would
    # delete just fine.
    if (not -d $path)
    {
        error ("Cannot recursively remove $user_path, as it is not a directory.");
        return 0;
    }

    eval {
        $@ = '';
        finddepth( # finddepth does a postorder traversal.
        {
            wanted => $delete_file_or_dir,
            no_chdir => 1, # We'll end up deleting directories, so prevent this.
        }, $path);
    };

    if ($@)
    {
        error ("Unable to remove directory $user_path: $@");
        return 0;
    }

    return 1;
}

# This function takes a given file and a build context, and installs it to a
# given location while expanding out template entries within the source file.
#
# The template language is *extremely* simple: <% foo %> is replaced entirely
# with the result of $ctx->getOption(foo, 'no-inherit'). If the result
# evaluates false for any reason than an exception is thrown. No quoting of
# any sort is used in the result, and there is no way to prevent expansion of
# something that resembles the template format.
#
# Multiple template entries on a line will be replaced.
#
# The destination file will be created if it does not exist. If the file
# already exists then an exception will be thrown.
# TODO: Allow for existing files if existing file was generated by
# kdesrc-build.
#
# Error handling: Any errors will result in an exception being thrown.
# Return value: There is no return value.
# Parameters:
#  Pathname to the source file (use absolute paths)
#  Pathname to the destination file (use absolute paths)
#  BuildContext to use for looking up template values
sub installTemplatedFile
{
    my ($sourcePath, $destinationPath, $ctx) = @_;
    assert_isa($ctx, 'ksb::BuildContext');

    open (my $input,  '<', $sourcePath) or
        croak_runtime("Unable to open template source $sourcePath: $!");
    open (my $output, '>', $destinationPath) or
        croak_runtime("Unable to open template output $destinationPath: $!");

    while (!eof ($input)) {
        my $line = readline($input);
        if (!defined ($line)) {
            croak_runtime("Failed to read from $sourcePath at line $.: $!");
            unlink($destinationPath);
        }

        # Some lines should only be present in the source as they aid with testing.
        next if $line =~ /kdesrc-build: filter/;

        $line =~
            s {
                <% \s*    # Template bracket and whitespace
                ([^\s%]+) # Capture variable name
                \s*%>     # remaining whitespace and closing bracket
              }
              {
                  $ctx->getOption($1, 'module') ||
                      croak_runtime("Invalid variable $1")
              }gxe;
              # Replace all matching expressions, use extended regexp w/
              # comments, and replacement is Perl code to execute.

        (print $output $line) or
            croak_runtime("Unable to write line to $destinationPath at line $.: $!");
    }
}

# This function installs a source file to a destination path, assuming the
# source file is a "templated" source file (see also installTemplatedFile), and
# records a digest of the file actually installed. This function will overwrite
# a destination if the destination is identical to the last-installed file.
#
# Error handling: Any errors will result in an exception being thrown.
# Return value: There is no return value.
# Parameters:
#  BuildContext to use for looking up template values,
#  The full path to the source file.
#  The full path to the destination file (incl. name)
#  The key name to use for searching/recording installed MD5 digest.
sub installCustomFile
{
    use File::Copy qw(copy);

    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my ($sourceFilePath, $destFilePath, $md5KeyName) = @_;
    my $baseName = basename($sourceFilePath);

    if (-e $destFilePath) {
        my $existingMD5 = $ctx->getPersistentOption('/digests', $md5KeyName) // '';

        if (fileDigestMD5($destFilePath) ne $existingMD5) {
            if (!$ctx->getOption('#delete-my-settings')) {
                error ("\tr[*] Installing \"b[$baseName]\" would overwrite an existing file:");
                error ("\tr[*]  y[b[$destFilePath]");
                error ("\tr[*] If this is acceptable, please delete the existing file and re-run,");
                error ("\tr[*] or pass b[--delete-my-settings] and re-run.");

                return;
            }
            elsif (!pretending()) {
                copy ($destFilePath, "$destFilePath.kdesrc-build-backup");
            }
        }
    }

    if (!pretending()) {
        installTemplatedFile($sourceFilePath, $destFilePath, $ctx);
        $ctx->setPersistentOption('/digests', $md5KeyName, fileDigestMD5($destFilePath));
    }
}

# This function installs the included sample .xsession and environment variable
# setup files, and records the md5sum of the installed results.
#
# If a file already exists, then its md5sum is taken and if the same as what
# was previously installed, is overwritten. If not the same, the original file
# is left in place and the .xsession is instead installed to
# .xsession-kdesrc-build
#
# Error handling: Any errors will result in an exception being thrown.
# Return value: There is no return value.
# Parameters:
#  BuildContext to use for looking up template values,
sub installCustomSessionDriver
{
    use FindBin qw($RealBin);
    use List::Util qw(first);
    use File::Copy qw(copy);

    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my @xdgDataDirs = split(':', $ENV{XDG_DATA_DIRS} || '/usr/local/share/:/usr/share/');
    my $xdgDataHome = $ENV{XDG_DATA_HOME} || "$ENV{HOME}/.local/share";

    # First we have to find the source
    my @searchPaths = ($RealBin, map { "$_/kdesrc-build" } ($xdgDataHome, @xdgDataDirs));

    s{/+$}{}   foreach @searchPaths; # Remove trailing slashes
    s{//+}{/}g foreach @searchPaths; # Remove duplicate slashes

    my $envScript = first { -f $_ } (
        map { "$_/sample-kde-env-master.sh" } @searchPaths
    );
    my $sessionScript = first { -f $_ } (
        map { "$_/sample-xsession.sh" } @searchPaths
    );
    my $userSample = first { -f $_ } (
        map { "$_/sample-kde-env-user.sh" } @searchPaths
    );

    if (!$envScript || !$sessionScript) {
        warning ("b[*] Unable to find helper files to setup a login session.");
        warning ("b[*] You will have to setup login yourself, or install kdesrc-build properly.");
        return;
    }

    my $destDir = $ENV{XDG_CONFIG_HOME} || "$ENV{HOME}/.config";
    super_mkdir($destDir) unless -d $destDir;

    installCustomFile($ctx, $envScript, "$destDir/kde-env-master.sh",
        'kde-env-master-digest');
    installCustomFile($ctx, $sessionScript, "$ENV{HOME}/.xsession",
        'xsession-digest');

    if (!pretending()) {
        if (! -e "$destDir/kde-env-user.sh") {
            copy($userSample, "$destDir/kde-env-user.sh") or do {
                warning ("b[*] Unable to install b[$userSample]: $!");
                warning ("b[*] You should create b[~/.config/kde-env-user.sh] yourself or fix the error and re-run");
            };
        }

        chmod (0744, "$ENV{HOME}/.xsession") or do {
            error ("\tb[r[*] Error making b[~/.xsession] executable: $!");
            error ("\tb[r[*] If this file is not executable you may not be able to login!");
        };
    }
}

# Reads a "line" from a file. This line is stripped of comments and extraneous
# whitespace. Also, backslash-continued multiple lines are merged into a single
# line.
#
# First parameter is the reference to the filehandle to read from.
# Returns the text of the line.
sub readNextLogicalLine
{
    my $fileReader = shift;

    while($_ = $fileReader->readLine()) {
        # Remove trailing newline
        chomp;

        # Replace \ followed by optional space at EOL and try again.
        if(s/\\\s*$//)
        {
            $_ .= $fileReader->readLine();
            redo;
        }

        s/#.*$//;        # Remove comments
        next if /^\s*$/; # Skip blank lines

        return $_;
    }

    return undef;
}

# Takes an input line, and extracts it into an option name, and simplified
# value. The value has "false" converted to 0, white space simplified (like in
# Qt), and tildes (~) in what appear to be path-like entries are converted to
# the home directory path.
#
# First parameter is the input line.
# Return value is (optionname, option-value)
sub split_option_value
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my $input = shift;
    my $optionRE = qr/\$\{([a-zA-Z0-9-]+)\}/;

    # The option is the first word, followed by the
    # flags on the rest of the line.  The interpretation
    # of the flags is dependant on the option.
    my ($option, $value) = ($input =~ /^\s*     # Find all spaces
                            ([-\w]+) # First match, alphanumeric, -, and _
                            # (?: ) means non-capturing group, so (.*) is $value
                            # So, skip spaces and pick up the rest of the line.
                            (?:\s+(.*))?$/x);

    $value = "" unless defined $value;

    # Simplify this.
    $value =~ s/\s+$//;
    $value =~ s/^\s+//;
    $value =~ s/\s+/ /;

    # Check for false keyword and convert it to Perl false.
    $value = 0 if lc($value) eq 'false';

    # Replace reference to global option with their value.
    # The regex basically just matches ${option-name}.
    my ($sub_var_name) = ($value =~ $optionRE);
    while ($sub_var_name)
    {
        my $sub_var_value = $ctx->getOption($sub_var_name) || '';
        if(!$ctx->hasOption($sub_var_value)) {
            warning (" *\n * WARNING: $sub_var_name is not set at line y[$.]\n *");
        }

        debug ("Substituting \${$sub_var_name} with $sub_var_value");

        $value =~ s/\${$sub_var_name}/$sub_var_value/g;

        # Replace other references as well.  Keep this RE up to date with
        # the other one.
        ($sub_var_name) = ($value =~ $optionRE);
    }

    # Replace tildes with home directory.
    1 while ($value =~ s"(^|:|=)~/"$1$ENV{'HOME'}/");

    return ($option, $value);
}

# Reads in the options from the config file and adds them to the option store.
# The first parameter is a BuildContext object to use for creating the returned
#     ksb::Module under.
# The second parameter is a reference to the file handle to read from.
# The third parameter is the module name. It can be either an
# already-constructed ksb::Module object (in which case it is used directly and any
# options read for the module are applied directly to the object), or it can be
# a string containing the module name (in which case a new ksb::Module object will
# be created). For global options the module name should be 'global', or just
# pass in the BuildContext for this param as well.
#
# The return value is the ksb::Module with options set as given in the configuration
# file for that module. If global options were being read then a BuildContext
# is returned (but that is-a ksb::Module anyways).
sub parse_module
{
    my ($ctx, $fileReader, $moduleOrName) = @_;
    assert_isa($ctx, 'ksb::BuildContext');

    my $rcfile = $ctx->rcFile();
    my $module;

    # Figure out what objects to store options into. If given, just use
    # that, otherwise use context or a new ksb::Module depending on the name.
    if (ref $moduleOrName) {
        $module = $moduleOrName;
        assert_isa($module, 'ksb::Module');
    }
    elsif ($moduleOrName eq 'global') {
        $module = $ctx;
    }
    else {
        $module = ksb::Module->new($ctx, $moduleOrName);
    }

    my $endWord = $module->isa('ksb::BuildContext') ? 'global' : 'module';
    my $endRE = qr/^end\s+$endWord/;

    # Read in each option
    while ($_ = readNextLogicalLine($fileReader))
    {
        last if m/$endRE/;

        # Sanity check, make sure the section is correctly terminated
        if(/^(module\s|module$)/)
        {
            error ("Invalid configuration file $rcfile at line $.\nAdd an 'end $endWord' before " .
                   "starting a new module.\n");
            die make_exception('Config', "Invalid $rcfile");
        }

        my ($option, $value) = split_option_value($ctx, $_);

        # Handle special options.
        if ($module->isa('ksb::BuildContext') && $option eq 'git-repository-base') {
            # This will be a hash reference instead of a scalar
            my ($repo, $url) = ($value =~ /^([a-zA-Z0-9_-]+)\s+(.+)$/);
            $value = $ctx->getOption($option) || { };

            if (!$repo || !$url) {
                error (<<"EOF");
The y[git-repository-base] option at y[b[$rcfile:$.]
requires a repository name and URL.

e.g. git-repository base y[b[kde] g[b[git://anongit.kde.org/]

Use this in a "module-set" group:

e.g.
module-set kdesupport-set
  repository y[b[kde]
  use-modules automoc akonadi soprano attica
end module-set
EOF
                die make_exception('Config', "Invalid git-repository-base");
            }

            $value->{$repo} = $url;
        }

        $module->setOption($option, $value);
    }

    return $module;
}

# Tries to download the kde_projects.xml file needed to make XML module support
# work. Only tries once per script run. If it does succeed, the result is saved
# to $srcdir/kde_projects.xml
#
# Returns the file handle that the database can be retrieved from. May throw an
# exception if an error occurred.
sub ensure_projects_xml_present
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');

    state $file;
    state $cachedSuccess;

    # See if we've already tried to download. If we ever try to download for
    # real, we end up unlinking the file if it didn't successfully complete the
    # download, so we shouldn't have to worry about a corrupt XML file hanging
    # out for all time.
    if (defined $cachedSuccess && !$cachedSuccess) {
        croak_internal("Attempted to find projects.xml after it already failed");
    }

    if ($cachedSuccess) {
        open my $fh, '<', $file or die make_exception('Runtime', "Unable to open $file: $!");
        return $fh;
    }

    # Not previously attempted, let's make a try.
    my $srcdir = $ctx->getSourceDir();
    my $fileHandleResult;

    super_mkdir($srcdir) unless -d "$srcdir";
    $file = "$srcdir/kde_projects.xml";
    my $url = "http://projects.kde.org/kde_projects.xml";

    my $result = 1;

    # Must use ->phases() directly to tell if we will be updating since
    # modules are not all processed until after this function is called...
    my $updating = grep { /^update$/ } (@{$ctx->phases()});
    if (!pretending() && $updating) {
        info (" * Downloading projects.kde.org project database...");
        $result = download_file($url, $file, $ctx->getOption('http-proxy'));
    }
    elsif (! -e $file) {
        note (" * Downloading projects.kde.org project database (will not be saved in pretend mode)...");

        # Unfortunately dumping the HTTP output straight to the XML parser is a
        # wee bit more complicated than I feel like dealing with => use a temp
        # file.
        (undef, $file) = tempfile('kde_projectsXXXXXX',
            SUFFIX=>'.xml', TMPDIR=>1, UNLINK=>0);
        $result = download_file($url, $file, $ctx->getOption('http-proxy'));
        open ($fileHandleResult, '<', $file) or croak_runtime("Unable to open KDE Project database $file: $!");
    }
    else {
        info (" * y[Using existing projects.kde.org project database], output may change");
        info (" * when database is updated next.");
    }

    $cachedSuccess = $result;

    if (!$result) {
        unlink $file if -e $file;
        croak_runtime("Unable to download kde_projects.xml for the kde-projects repository!");
    }

    if (!$fileHandleResult) {
        open ($fileHandleResult, '<', $file) or die
            make_exception('Runtime', "Unable to open $file: $!");
    }

    return $fileHandleResult;
}

# Reads in a "moduleset".
#
# First parameter is the filehandle to the config file to read from.
# Second parameter is the name of the moduleset, which is really the name
# of the base repository to use.
# Returns the expanded list of module names to include.
sub parse_moduleset
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my $fileReader = shift;
    my $moduleSetName = shift || '';
    my $repoSet = $ctx->getOption('git-repository-base');
    my $rcfile = $ctx->rcFile();
    my @modules;
    my %optionSet; # We read all options, and apply them to all modules
    my $startLine = $.; # For later error messages

    while($_ = readNextLogicalLine($fileReader)) {
        last if /^end\s+module(-?set)?$/;

        my ($option, $value) = split_option_value($ctx, $_);

        if ($option eq 'use-modules') {
            @modules = split(' ', $value);

            if (not @modules) {
                error ("No modules were selected for the current module-set");
                error ("in the y[use-modules] on line $. of $rcfile");
                die make_exception('Config', 'Invalid use-modules');
            }
        }
        elsif ($option eq 'set-env') {
            handle_set_env(\%optionSet, $option, $value);
        }
        else {
            $optionSet{$option} = $value;
        }
    }

    # Check before we start looping whether the user did something silly.
    if (exists $optionSet{'repository'} &&
        ($optionSet{'repository'} ne KDE_PROJECT_ID) &&
        not exists $repoSet->{$optionSet{'repository'}})
    {
        my $projectID = KDE_PROJECT_ID;
        my $moduleSetId = "module-set";
        $moduleSetId = "module-set ($moduleSetName)" if $moduleSetName;

        error (<<EOF);
There is no repository assigned to y[b[$optionSet{repository}] when assigning a
$moduleSetId on line $startLine of $rcfile.

These repositories are defined by g[b[git-repository-base] in the global
section of $rcfile.
Make sure you spelled your repository name right!

If you are trying to pull the module information from the KDE
http://projects.kde.org/ website, please use b[$projectID] for the value of
the b[repository] option.
EOF

        die make_exception('Config', 'Unknown repository base');
    }

    my @moduleList; # module names converted to ksb::Module objects.
    my $selectedRepo;
    my $usingXML = (exists $optionSet{'repository'}) &&
                    $optionSet{'repository'} eq KDE_PROJECT_ID;

    # Setup default options for each module
    # Extraction of relevant XML modules will be handled immediately after
    # this phase of execution.
    for my $module (@modules) {
        my $moduleName = $module;

        # Remove trailing .git for module name
        $moduleName =~ s/\.git$// unless $usingXML;

        my $newModule = ksb::Module->new($ctx, $moduleName);
        $newModule->setModuleSet($moduleSetName);
        $newModule->setScmType($usingXML ? 'proj' : 'git');
        push @moduleList, $newModule;

        # Dump all options into the existing ksb::Module's options.
        $newModule->setOption(%optionSet);

        # Fixup for the special repository handling if need be.
        if (!$usingXML && exists $optionSet{'repository'}) {
            $selectedRepo = $repoSet->{$optionSet{'repository'}} unless $selectedRepo;
            $newModule->setOption('repository', $selectedRepo . $moduleName);
        }
    }

    if (not scalar @moduleList) {
        warning ("No modules were defined for the module-set in r[b[$rcfile] starting at line y[b[$startLine]");
        warning ("You should use the g[b[use-modules] option to make the module-set useful.");
    }

    return @moduleList;
}

# Goes through the provided modules that have the 'proj' type (i.e. XML
# projects.kde.org database) and expands the proj-types into their equivalent
# git modules, and returns the fully expanded list. Non-proj modules are
# included in the sequence they were originally.
sub expandXMLModules
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my @modules = @_;

    # If we detect a KDE project we want to also pull in a "build support"
    # repository that will contain metadata such as which modules depend on
    # which other ones, what modules shouldn't be built, etc.
    my $repositoryMetadataRequired = 0;

    # Using a sub allows me to use the 'return' keyword.
    my $filter = sub {
        my $moduleSet = shift;

        # Only attempt to expand out XML-based modules.
        return $moduleSet if !$moduleSet->scm()->isa('ksb::Updater::KDEProject');

        my $databaseFile = ensure_projects_xml_present($ctx) or
            croak_runtime("kde-projects repository information could not be downloaded: $!");

        # At this point we know we'll need the kde-build-metadata module, force
        # it in by setting a flag to be used by the higher-level subroutine.
        $repositoryMetadataRequired = 1;

        my $name = $moduleSet->name();
        my $srcdir = $ctx->getSourceDir();

        my $xmlReader = ksb::KDEXMLReader->new($databaseFile);
        my $protocol = $ctx->getOption('git-desired-protocol') || 'git';

        if (!list_has(['git', 'http'], $protocol)) {
            error (" b[y[*] Invalid b[git-desired-protocol] $protocol");
            error (" b[y[*] Try setting this option to 'git' if you're not using a proxy");
            croak_runtime ("Invalid git-desired-protocol: $protocol");
        }

        my @allXmlResults = $xmlReader->getModulesForProject($name, $protocol);

        # It's possible to match modules which are marked as inactive on
        # projects.kde.org, elide those.
        my @xmlResults = grep { $_->{'active'} ne 'false' } (@allXmlResults);

        if (!@xmlResults) {
            # If this was a "guessed XML module" then we guessed wrong, and it's really
            # a misspelling.
            if ($moduleSet->getOption('#guessed-kde-project')) {
                croak_runtime("Unknown module or module-set: $name");
            }

            warning (" y[b[*] Module y[$name] is apparently XML-based, but contains no\n" .
                     "active modules to build!");
            my $count = scalar @allXmlResults;
            if ($count > 0) {
                warning ("\tAlthough no active modules are available, there were\n" .
                         "\t$count inactive modules. Perhaps the git modules are not ready?");
            }
        }

        # Setup module options. This alters the results in @xmlResults.
        foreach (@xmlResults) {
            my $result = $_;
            my $repo = $result->{'repo'};

            # Prefer kde: alias to normal clone URL.
            $repo =~ s(^git://anongit\.kde\.org/)(kde:);

            # This alters the item we were looking at.
            $_ = ksb::Module->new($ctx, $result->{'name'});
            $_->setScmType('git');
            $_->cloneOptionsFrom($moduleSet);
            $_->setModuleSet($moduleSet->moduleSet());
            $_->setOption('repository', $repo);
            $_->setOption('#xml-full-path', $result->{'fullName'});
            $_->setOption('#branch:stable', $result->{'branch:stable'});

            my $tarball = $result->{'tarball'};
            $_->setOption('#snapshot-tarball', $tarball) if $tarball;
        };

        return @xmlResults;
    };

    my @results = map { &$filter($_) } (@modules);

    if ($repositoryMetadataRequired) {
        my $repoMetadataModule = ksb::Module->new($ctx, 'kde-build-metadata');
        $repoMetadataModule->setScmType('metadata');

        # Manually run this through the filter so all the right magic happens.
        ($repoMetadataModule) = &$filter($repoMetadataModule);

        # Ensure we only ever try to update source, not build.
        $repoMetadataModule->phases()->phases('update');
        $repoMetadataModule->setScmType('metadata');
        $repoMetadataModule->setOption('disable-snapshots', 1);
        $repoMetadataModule->setOption('branch', 'master');

        unshift @results, $repoMetadataModule;
    }

    return @results;
}

# This subroutine takes a reference to the current module list (specifically a
# list of ksb::Module objects), and takes a reference to the list of ksb::Module objects
# read in from the config file.
#
# For each module in the first list, it is checked to see if options have been
# read in for it, and if so it is left alone.
#
# If the module does not have any options for it, it is assumed that the user
# might mean a named module set (i.e. the module is the name of a module-set),
# and /if/ any of the Modules in the second list are recorded as having come
# from a module set matching the name of the current module, it is used
# instead.
#
# The processed module list is the return value.
sub expandModuleSets
{
    my ($buildModuleList, $knownModules) = @_;

    my $filter = sub {
        my $setName = $_->name();

        # If the module name matches a read-in ksb::Module, then it's not a set.
        return $_ if grep { $setName eq $_->name() } (@$knownModules);

        # XML module can only happen if forced by user on command line, allow
        # it.
        return $_ if $_->scmType() eq 'proj';

        # Likewise with l10n module.
        return $_ if $_->scmType() eq 'l10n';

        # Otherwise assume it's a set, replace this with all sub-modules in that
        # module set.
        my @modulesInSet = grep
            { ($_->moduleSet() // '') eq $setName }
        (@$knownModules);

        if (!@modulesInSet) {
            # If we make it to this point the module is either completely
            # unknown, or possibly part of a kde-projects module-set (it can't
            # be part of a regular module-set as those modules are already in
            # @knownModules). To allow things to continue we will
            # optimistically mark the module as a kde-projects module and then
            # cross our fingers...
            $_->setScmType('proj');
            $_->setOption('#guessed-kde-project', 1);
            push @modulesInSet, $_;
        }

        return @modulesInSet;
    };

    return map { &$filter } (@$buildModuleList);
}

# This subroutine reads in the settings from the user's configuration
# file. The filehandle to read from should be passed in as the first
# parameter. The filehandle should be something that the <> operator works
# on, usually some subclass of IO::Handle.
sub read_options
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my $fh = shift;
    my @module_list;
    my $rcfile = $ctx->rcFile();
    my ($option, $modulename, %readModules);

    my $fileReader = RecursiveFH->new();
    $fileReader->addFilehandle($fh);

    # Read in global settings
    while ($_ = $fileReader->readLine())
    {
        s/#.*$//;       # Remove comments
        s/^\s*//;       # Remove leading whitespace
        next if (/^\s*$/); # Skip blank lines

        # First command in .kdesrc-buildrc should be a global
        # options declaration, even if none are defined.
        if (not /^global\s*$/)
        {
            error ("Invalid configuration file: $rcfile.");
            error ("Expecting global settings section at b[r[line $.]!");
            die make_exception('Config', 'Missing global section');
        }

        # Now read in each global option.
        parse_module($ctx, $fileReader, 'global');
        last;
    }

    my $using_default = 1;

    # Now read in module settings
    while ($_ = $fileReader->readLine())
    {
        s/#.*$//;          # Remove comments
        s/^\s*//;          # Remove leading whitespace
        next if (/^\s*$/); # Skip blank lines

        # Get modulename (has dash, dots, slashes, or letters/numbers)
        ($modulename) = /^module\s+([-\/\.\w]+)\s*$/;

        if (not $modulename)
        {
            my $moduleSetRE = qr/^module-set\s*([-\/\.\w]+)?\s*$/;
            ($modulename) = m/$moduleSetRE/;

            # modulename may be blank -- use the regex directly to match
            if (not /$moduleSetRE/) {
                error ("Invalid configuration file $rcfile!");
                error ("Expecting a start of module section at r[b[line $.].");
                die make_exception('Config', 'Ungrouped/Unknown option');
            }

            # A moduleset can give us more than one module to add.
            push @module_list, parse_moduleset($ctx, $fileReader, $modulename);
        }
        else {
            # Overwrite options set for existing modules.
            if (my @modules = grep { $_->name() eq $modulename } @module_list) {
                # We check for definedness as a module-set can exist but be
                # unnamed.
                if (!defined $modules[0]->moduleSet()) {
                    warning ("Multiple module declarations for $modules[0]");
                }

                parse_module($ctx, $fileReader, $modules[0]); # Don't re-add
            }
            else {
                push @module_list, parse_module($ctx, $fileReader, $modulename);
            }
        }

        # Don't build default modules if user has their own wishes.
        $using_default = 0;
    }

    # All modules and their options have been read, filter out modules not
    # to update or build, based on the --ignore-modules option already present
    # on the command line. manual-update and manual-build are also relevant,
    # but handled in updateModulePhases.
    @module_list = grep {
        not exists $ignore_list{$_->name()}
    } (@module_list);

    # If the user doesn't ask to build any modules, build a default set.
    # The good question is what exactly should be built, but oh well.
    if ($using_default) {
        $ctx->setup_default_modules();
        return ();
    }

    return @module_list;
}

# Print out an error message, and a list of modules that match that error
# message.  It will also display the log file name if one can be determined.
# The message will be displayed all in uppercase, with PACKAGES prepended, so
# all you have to do is give a descriptive message of what this list of
# packages failed at doing.
sub output_failed_module_list
{
    my ($ctx, $message, @fail_list) = @_;
    assert_isa($ctx, 'ksb::BuildContext');

    $message = uc $message; # Be annoying

    debug ("Message is $message");
    debug ("\tfor ", join(', ', @fail_list));

    if (scalar @fail_list > 0)
    {
        my $homedir = $ENV{'HOME'};
        my $logfile;

        warning ("\nr[b[<<<  PACKAGES $message  >>>]");

        for my $module (@fail_list)
        {
            $logfile = $module->getOption('#error-log-file');

            # async updates may cause us not to have a error log file stored.  There's only
            # one place it should be though, take advantage of side-effect of log_command()
            # to find it.
            if (not $logfile) {
                my $logdir = $module->getLogDir() . "/error.log";
                $logfile = $logdir if -e $logdir;
            }

            $logfile = "No log file" unless $logfile;
            $logfile =~ s|$homedir|~|;

            warning ("r[$module]") if pretending();
            warning ("r[$module] - g[$logfile]") if not pretending();
        }
    }
}

# This subroutine reads the fail_lists dictionary to automatically call
# output_failed_module_list for all the module failures in one function
# call.
sub output_failed_module_lists
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');

    # This list should correspond to the possible phase names (although
    # it doesn't yet since the old code didn't, TODO)
    for my $phase ($ctx->phases()->phases())
    {
        my @failures = $ctx->failedModulesInPhase($phase);
        output_failed_module_list($ctx, "failed to $phase", @failures);
    }

    # See if any modules fail continuously and warn specifically for them.
    my @super_fail = grep {
        ($_->getPersistentOption('failure-count') // 0) > 3
    } (@{$ctx->moduleList()});

    if (@super_fail)
    {
        warning ("\nThe following modules have failed to build 3 or more times in a row:");
        warning ("\tr[b[$_]") foreach @super_fail;
        warning ("\nThere is probably a local error causing this kind of consistent failure, it");
        warning ("is recommended to verify no issues on the system.\n");
    }
}

# This subroutine extract the value from options of the form --option=value,
# which can also be expressed as --option value.  The first parameter is the
# option that the user passed to the cmd line (e.g. --prefix=/opt/foo), and
# the second parameter is a reference to the list of command line options.
# The return value is the value of the option (the list might be shorter by
# 1, copy it if you don't want it to change), or undef if no value was
# provided.
sub extract_option_value($\@)
{
    my ($option, $options_ref) = @_;

    if ($option =~ /=/)
    {
        my @value = split(/=/, $option);
        shift @value; # We don't need the first one, that the --option part.

        return undef if (scalar @value == 0);

        # If we have more than one element left in @value it's because the
        # option itself has an = in it, make sure it goes back in the answer.
        return join('=', @value);
    }

    return undef if scalar @{$options_ref} == 0;
    return shift @{$options_ref};
}

# Like extract_option_value, but throws an exception if the value is not actually present,
# so you don't have to check for it yourself. If you do get a return value, it will be
# defined to something.
sub extract_option_value_required($\@)
{
    my ($option, $options_ref) = @_;
    my $returnValue = extract_option_value($option, @$options_ref);

    if (not defined $returnValue) {
        croak_runtime("Option $option needs to be set to some value instead of left blank");
    }

    return $returnValue;
}

# Utility subroutine to handle setting the environment variable type of value.
# Returns true (non-zero) if this subroutine handled everything, 0 otherwise.
# The first parameter should by the reference to the hash with the 'set-env'
# hash ref, second parameter is the exact option to check, and the third
# option is the value to set that option to.
sub handle_set_env
{
    my ($href, $option, $value) = @_;

    return 0 if $option !~ /^#?set-env$/;

    my ($var, @values) = split(' ', $value);

    ${$href}{$option} //= { };
    ${$href}{$option}->{$var} = join(' ', @values);

    return 1;
}

# Subroutine to process the command line arguments, which should be passed as
# a list. The list of module names passed on the command line will be returned,
# In addition, a second parameter should be passed, a reference to a hash that
# will hold options that cannot be set until the rc-file is read.
#
# NOTE: One exception to the return value is that if --run is passed, the list
# of options to pass to the new program is returned instead (you can tell by
# evaluating the '#start-program' option.
# NOTE: Don't call finish() from this routine, the lock hasn't been obtained.
sub process_arguments
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my $pendingOptions = shift;
    my $phases = $ctx->phases();
    my @savedOptions = @_; # Used for --debug
    my @options = @_;
    my $arg;
    my $version = "kdesrc-build $SCRIPT_VERSION";
    my $author = <<DONE;
$version was written (mostly) by:
  Michael Pyne <mpyne\@kde.org>

Many people have contributed code, bugfixes, and documentation.

Please report bugs using the KDE Bugzilla, at http://bugs.kde.org/
DONE

    my @enteredModules;

    while ($_ = shift @options)
    {
        SWITCH: {
            /^(--version)$/      && do { print "$version\n"; exit; };
            /^--author$/         && do { print $author; exit; };
            /^(-h)|(--?help)$/   && do {
                print <<DONE;
$version
http://kdesrc-build.kde.org/

This script automates the download, build, and install process for KDE software
using the latest available source code.

You should first setup a configuration file (~/.kdesrc-buildrc). You can do
this by running the kdesrc-build-setup program, which should be included with
this one.  You can also copy the kdesrc-buildrc-sample file (which should be
included) to ~/.kdesrc-buildrc.

Basic synopsis, after setting up .kdesrc-buildrc:
\$ $0 [--options] [module names]

The module names can be either the name of an individual module (as set in your
configuration with a module declaration, or a use-modules declaration), or of a
module set (as set with a module-set declaration).

If you don\'t specify any particular module names, then every module you have
listed in your configuration will be built, in the order listed.

Copyright (c) 2003 - 2011 $author
The script is distributed under the terms of the GNU General Public License
v2, and includes ABSOLUTELY NO WARRANTY!!!

Options:
    --no-src             Skip contacting the source server.
    --no-build           Skip the build process.
    --no-install         Don't automatically install after build.

    --src-only           Only update the source code (Identical to --no-build
                         at this point).
    --build-only         Build only, don't perform updates or install.

    --rc-file=<filename> Read configuration from filename instead of default.

    --resume-from=<pkg>  Starts building from the given package, without
                         performing the source update.
    --resume-after=<pkg> Starts building after the given package, without
                         performing the source update.

    --reconfigure        Run CMake/configure again, but don't clean the build
                         directory.
    --build-system-only  Create the build infrastructure, but don't actually
                         perform the build.

    --<option>=          Any unrecognized options are added to the global
                         configuration, overriding any value that may exist.
    --<module>,<option>= Likewise, this allows you to override any module
                         specific option from the command line.

    --pretend (or -p)    Don't actually contact the source server, run make,
                         or create/delete files and directories.  Instead,
                         output what the script would have done.
    --refresh-build      Start the build from scratch.

    --help               You\'re reading it. :-)
    --version            Output the program version.

You can get more help by going online to http://kdesrc-build.kde.org/ to view
the online documentation.  If you have installed kdesrc-build you may also be
able to view the documentation using KHelpCenter or Konqueror at the URL
help:/kdesrc-build
DONE
                # We haven't done any locking... no need to finish()
                exit 0;
            };

            /^--install$/ && do {
                $run_mode = 'install';
                $phases->phases('install');

                last SWITCH;
            };

            /^--uninstall$/ && do {
                $run_mode = 'uninstall';
                $phases->phases('uninstall');

                last SWITCH;
            };

            /^--no-snapshots$/ && do {
                $ctx->setOption('#disable-snapshots', 1);
                last SWITCH;
            };

            /^--no-(src|svn)$/ && do {
                $phases->filterOutPhase('update');
                last SWITCH;
            };

            /^--no-install$/ && do {
                $phases->filterOutPhase('install');
                last SWITCH;
            };

            /^--no-tests$/ && do {
                # The "right thing" to do
                $phases->filterOutPhase('test');

                # What actually works at this point.
                $ctx->setOption('#run-tests', 0);
                last SWITCH;
            };

            /^--(force-build)|(no-build-when-unchanged)$/ && do {
                $ctx->setOption('#build-when-unchanged', 1);
                last SWITCH;
            };

            /^(-v)|(--verbose)$/ && do {
                $ctx->setOption('#debug-level', ksb::Debug::WHISPER);
                last SWITCH;
            };

            /^(-q)|(--quiet)$/ && do {
                $ctx->setOption('#debug-level', ksb::Debug::NOTE);
                last SWITCH;
            };

            /^--really-quiet$/ && do {
                $ctx->setOption('#debug-level', ksb::Debug::WARNING);
                last SWITCH;
            };

            /^--debug$/ && do {
                $ctx->setOption('#debug-level', ksb::Debug::DEBUG);
                debug ("Commandline was: ", join(', ', @savedOptions));
                last SWITCH;
            };

            /^--reconfigure$/ && do {
                $ctx->setOption('#reconfigure', 1);
                last SWITCH;
            };

            /^--color$/ && do {
                $ctx->setOption('#colorful-output', 1);
                last SWITCH;
            };

            /^--no-color$/ && do {
                $ctx->setOption('#colorful-output', 0);
                last SWITCH;
            };

            /^--no-build$/ && do {
                $phases->filterOutPhase('build');
                last SWITCH;
            };

            /^--async$/ && do {
                $ctx->setOption('#async', 1);
                last SWITCH;
            };

            /^--no-async$/ && do {
                $ctx->setOption('#async', 0);
                last SWITCH;
            };

            # Although equivalent to --no-build at this point, someday the
            # script may interpret the two differently, so get ready now.
            /^--(src|svn)-only$/ && do {      # Identically to --no-build
                $phases->phases('update');

                # We have an auto-switching function that we only want to run
                # if --src-only was passed to the command line, so we still
                # need to set a flag for it.
                $ctx->setOption('#allow-auto-repo-move', 1);
                last SWITCH;
            };

            # Don't run source updates or install
            /^--build-only$/ && do {
                $phases->phases('build');
                last SWITCH;
            };

            # Start up a program with the environment variables as
            # read from the config file.
            /^--run=?/ && do {
                my $program = extract_option_value_required($_, @options);
                $ctx->setOption('#start-program', $program);

                # Save remaining command line options to pass to the program.
                return @options;
            };

            /^--build-system-only$/ && do {
                $ctx->setOption('#build-system-only', 1);
                last SWITCH;
            };

            /^--rc-file=?/ && do {
                my $rcfile = extract_option_value_required($_, @options);
                $ctx->setRcFile($rcfile);

                last SWITCH;
            };

            /^--prefix=?/ && do {
                my $prefix = extract_option_value_required($_, @options);

                $ctx->setOption('#kdedir', $prefix);
                $ctx->setOption('#reconfigure', 1);

                last SWITCH;
            };

            /^--nice=?/ && do {
                my $niceness = extract_option_value_required($_, @options);

                $ctx->setOption('#niceness', $niceness);
                last SWITCH;
            };

            /^--ignore-modules$/ && do {
                # We need to keep read_options() from adding these modules to
                # the build list, taken care of by ignore_list.  We then need
                # to remove the modules from the command line, taken care of
                # by the @options = () statement;
                my @innerOptions = ();
                foreach (@options)
                {
                    if (/^-/)
                    {
                        push @innerOptions, $_;
                    }
                    else
                    {
                        $ignore_list{$_} = 1;

                        # the pattern match doesn't work with $_, alias it.
                        my $module = $_;
                        @enteredModules = grep (!/^$module$/, @enteredModules);
                    }
                }
                @options = @innerOptions;

                last SWITCH;
            };

            /^(--dry-run)|(--pretend)|(-p)$/ && do {
                $ctx->setOption('#pretend', 1);
                # Simulate the build process too.
                $ctx->setOption('#build-when-unchanged', 1);
                last SWITCH;
            };

            /^--refresh-build$/ && do {
                $ctx->setOption('#refresh-build', 1);
                last SWITCH;
            };

            /^--delete-my-patches$/ && do {
                $ctx->setOption('#delete-my-patches', 1);
                last SWITCH;
            };

            /^--delete-my-settings$/ && do {
                $ctx->setOption('#delete-my-settings', 1);
                last SWITCH;
            };

            /^(--revision|-r)=?/ && do {
                my $revision = extract_option_value_required($_, @options);
                $ctx->setOption('#revision', $revision);

                last SWITCH;
            };

            /^--resume-from=?/ && do {
                $_ = extract_option_value_required($_, @options);
                $ctx->setOption('#resume-from', $_);

                last SWITCH;
            };

            /^--resume-after=?/ && do {
                $_ = extract_option_value_required($_, @options);
                $ctx->setOption('#resume-after', $_);

                last SWITCH;
            };

            /^--/ && do {
                # First let's see if they're trying to override a global option.
                my ($option) = /^--([-\w\d\/]+)/;
                my $value = extract_option_value($_, @options);

                if ($ctx->hasOption($option))
                {
                    $ctx->setOption("#$option", $value);
                }
                else
                {
                    # Module specific option.  The module options haven't been
                    # read in, so we'll just have to assume that the module the
                    # user passes actually does exist.
                    my ($module, $option) = /^--([\w\/-]+),([-\w\d\/]+)/;

                    if (not $module)
                    {
                        print "Unknown option $_\n";
                        exit 8;
                    }

                    ${$pendingOptions}{$module}{"$option"} = $value;
                }

                last SWITCH;
            };

            /^-/ && do { print "WARNING: Unknown option $_\n"; last SWITCH; };

            # Strip trailing slashes.
            s/\/*$//;
            push @enteredModules, $_; # Reconstruct correct @options
        }
    }

    # Don't go async if only performing one phase.  It (should) work but why
    # risk it?
    if (scalar $phases->phases() == 1)
    {
        $ctx->setOption('#async', 0);
    }

    return map { ksb::Module->new($ctx, $_) } (@enteredModules);
}

sub updateModulePhases
{
    whisper ("Filtering out module phases.");
    for my $module (@_) {
        if ($module->getOption('manual-update') ||
            $module->getOption('no-svn') || $module->getOption('no-src'))
        {
            $module->phases()->clear();
            next;
        }

        if ($module->getOption('manual-build')) {
            $module->phases()->filterOutPhase('build');
            $module->phases()->filterOutPhase('test');
            $module->phases()->filterOutPhase('install');
        }

        $module->phases()->filterOutPhase('install') unless $module->getOption('install-after-build');
        $module->phases()->addPhase('test') if $module->getOption('run-tests');
    }

    return @_;
}

# Subroutine to split a url into a protocol and host
sub split_url
{
    my $url = shift;
    my ($proto, $host) = ($url =~ m|([^:]*)://([^/]*)/|);

    return ($proto, $host);
}

# This subroutine checks if we are supposed to use ssh agent by examining the
# environment, and if so checks if ssh-agent has a list of identities.  If it
# doesn't, we run ssh-add (with no arguments) and inform the user.  This can
# be controlled with the disable-agent-check parameter.
sub check_for_ssh_agent
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');

    # Don't bother with all this if the user isn't even using SSH.
    return 1 if pretending();

    my @svnServers = grep {
        $_->scmType() eq 'svn'
    } ($ctx->modulesInPhase('update'));

    my @gitServers = grep {
        $_->scmType() eq 'git'
    } ($ctx->modulesInPhase('update'));

    my @sshServers = grep {
        my ($proto, $host) = split_url($_->getOption('svn-server'));

        # Check if ssh is explicitly used in the proto, or if the host is the
        # developer main svn.
        (defined $proto && $proto =~ /ssh/) || (defined $host && $host =~ /^svn\.kde\.org/);
    } @svnServers;

    push @sshServers, grep {
        # Check for git+ssh:// or git@git.kde.org:/path/etc.
        my $repo = $_->getOption('repository');
        ($repo =~ /^git\+ssh:\/\//) || ($repo =~ /^[a-zA-Z0-9_.]+@.*:\//);
    } @gitServers;

    whisper ("\tChecking for SSH Agent") if (scalar @sshServers);
    return 1 if (not @sshServers) or $ctx->getOption('disable-agent-check');

    # We're using ssh to download, see if ssh-agent is running.
    return 1 unless exists $ENV{'SSH_AGENT_PID'};

    my $pid = $ENV{'SSH_AGENT_PID'};

    # It's supposed to be running, let's see if there exists the program with
    # that pid (this check is linux-specific at the moment).
    if (-d "/proc" and not -e "/proc/$pid")
    {
        warning ("r[ *] SSH Agent is enabled, but y[doesn't seem to be running].");
        warning ("Since SSH is used to download from Subversion you may want to see why");
        warning ("SSH Agent is not working, or correct the environment variable settings.");

        return 0;
    }

    # The agent is running, but does it have any keys?  We can't be more specific
    # with this check because we don't know what key is required.
    my $noKeys = 0;

    filter_program_output(sub { $noKeys ||= /no identities/ }, 'ssh-add', '-l');

    if ($noKeys)
    {
        # Use print so user can't inadvertently keep us quiet about this.
        print ksb::Debug::colorize (<<EOF);
b[y[*] SSH Agent does not appear to be managing any keys.  This will lead to you
  being prompted for every module update for your SSH passphrase.  So, we're
  running g[ssh-add] for you.  Please type your passphrase at the prompt when
  requested, (or simply Ctrl-C to abort the script).
EOF
        my @commandLine = ('ssh-add');
        my $identFile = $ctx->getOption('ssh-identity-file');
        push (@commandLine, $identFile) if $identFile;

        my $result = system (@commandLine);
        if ($result) # Run this code for both death-by-signal and nonzero return
        {
            my $rcfile = $ctx->rcFile();

            print "\nUnable to add SSH identity, aborting.\n";
            print "If you don't want kdesrc-build to check in the future,\n";
            print ksb::Debug::colorize ("Set the g[disable-agent-check] option to g[true] in your $rcfile.\n\n");

            return 0;
        }
    }

    return 1;
}

# Subroutine to update a list of modules.  The first
# parameter is a reference of a list of the modules to update.
# If the module has not already been checkout out, this subroutine
# will do so for you.
#
# The second parameter should be the build context (ksb::BuildContext)
# for this run.
#
# The $ipc variable contains an object that is responsible for communicating
# the status of building the modules.  This function must account for every
# module in $ctx's update phase to $ipc before returning.
#
# Returns 0 on success, non-zero on error.
sub handle_updates
{
    my ($ipc, $ctx) = @_;
    my $kdesrc = $ctx->getSourceDir();
    my @update_list = $ctx->modulesInPhase('update');

    # No reason to print out the text if we're not doing anything.
    if (!@update_list)
    {
        $ipc->sendIPCMessage(ksb::IPC::ALL_UPDATING, "update-list-empty");
        return 0;
    }

    if (not check_for_ssh_agent($ctx))
    {
        $ipc->sendIPCMessage(ksb::IPC::ALL_FAILURE, "ssh-failure");
        return 1;
    }

    # Be much quieter if operating multiprocess and the user has not chosen a
    # different mode.
    if ($ipc->supportsConcurrency() && !$ctx->getOption('#debug-level'))
    {
        $ctx->setOption('#debug-level', ksb::Debug::WARNING);
    }

    if (grep { $_->scm()->isa('ksb::Updater::Git') } @update_list) {
        ksb::Updater::Git::verifyGitConfig();
    }

    note ("<<<  Updating Source Directories  >>>");
    info (" "); # Add newline for aesthetics unless in quiet mode.

    if (not -e $kdesrc)
    {
        whisper ("KDE source download directory doesn't exist, creating.\n");
        if (not super_mkdir ($kdesrc))
        {
            error ("Unable to make directory r[$kdesrc]!");
            $ipc->sendIPCMessage(ksb::IPC::ALL_FAILURE, "no-source-dir");

            return 1;
        }
    }

    # Once at this point, any errors we get should be limited to a module,
    # which means we can tell the build thread to start.
    $ipc->sendIPCMessage(ksb::IPC::ALL_UPDATING, "starting-updates");

    # Make sure KDE's SSL signature is present since --non-interactive is
    # passed to svn.
    if (grep { $_->scmType() eq 'svn' } @update_list) {
        ksb::Updater::Svn::_install_missing_ssl_signature();
    }

    my $hadError = 0;
    foreach my $module (@update_list)
    {
        # Note that this must be in this order to avoid accidentally not
        # running ->update() from short-circuiting if an error is noted.
        $hadError = !$module->update($ipc, $ctx) || $hadError;
    }

    info ("<<<  Update Complete  >>>\n");
    return $hadError;
}

# Returns a hash digest of the given options in the list.  The return value is
# base64-encoded at this time.
#
# Note: Don't be dumb and pass data that depends on execution state as the
# returned hash is almost certainly not useful for whatever you're doing with
# it.  (i.e. passing a reference to a list is not helpful, pass the list itself)
#
# Parameters: List of scalar values to hash.
# Return value: base64-encoded hash value.
sub get_list_digest
{
    use Digest::MD5 "md5_base64"; # Included standard with Perl 5.8

    return md5_base64(@_);
}

# Subroutine to run CMake to create the build directory for a module.
# CMake is not actually run if pretend mode is enabled.
#
# First parameter is the module to run cmake on.
# Return value is the shell return value as returned by log_command().  i.e.
# 0 for success, non-zero for failure.
sub safe_run_cmake
{
    my $module = assert_isa(shift, 'ksb::Module');
    my $srcdir = $module->fullpath('source');
    my @commands = split_quoted_on_whitespace ($module->getOption('cmake-options'));

    # grep out empty fields
    @commands = grep {!/^\s*$/} @commands;

    # Add -DBUILD_foo=OFF options for the directories in do-not-compile.
    # This will only work if the CMakeLists.txt file uses macro_optional_add_subdirectory()
    my @masked_directories = split(' ', $module->getOption('do-not-compile'));
    push @commands, "-DBUILD_$_=OFF" foreach @masked_directories;

    # Get the user's CXXFLAGS, use them if specified and not already given
    # on the command line.
    my $cxxflags = $module->getOption('cxxflags');
    if ($cxxflags and not grep { /^-DCMAKE_CXX_FLAGS(:\w+)?=/ } @commands)
    {
        push @commands, "-DCMAKE_CXX_FLAGS:STRING=$cxxflags";
    }

    my $prefix = $module->installationPath();

    push @commands, "-DCMAKE_INSTALL_PREFIX=$prefix";

    if ($module->getOption('run-tests') &&
        !grep { /^\s*-DKDE4_BUILD_TESTS(:BOOL)?=(ON|TRUE|1)\s*$/ } (@commands)
       )
    {
        whisper ("Enabling tests");
        push @commands, "-DKDE4_BUILD_TESTS:BOOL=ON";

        # Also enable phonon tests.
        if ($module =~ /^phonon$/) {
            push @commands, "-DPHONON_BUILD_TESTS:BOOL=ON";
        }
    }

    if ($module->getOption('run-tests') eq 'upload')
    {
        whisper ("Enabling upload of test results");
        push @commands, "-DBUILD_experimental:BOOL=ON";
    }

    unshift @commands, 'cmake', $srcdir; # Add to beginning of list.

    my $old_options =
        $module->getPersistentOption('last-cmake-options') || '';
    my $builddir = $module->fullpath('build');

    if (($old_options ne get_list_digest(@commands)) ||
        $module->getOption('reconfigure') ||
        ! -e "$builddir/CMakeCache.txt" # File should exist only on successful cmake run
       )
    {
        info ("\tRunning g[cmake]...");

        # Remove any stray CMakeCache.txt
        safe_unlink ("$srcdir/CMakeCache.txt")   if -e "$srcdir/CMakeCache.txt";
        safe_unlink ("$builddir/CMakeCache.txt") if -e "$builddir/CMakeCache.txt";

        $module->setPersistentOption('last-cmake-options', get_list_digest(@commands));
        return log_command($module, "cmake", \@commands);
    }

    # Skip cmake run
    return 0;
}

# Subroutine to recursively symlink a directory into another location, in a
# similar fashion to how the XFree/X.org lndir() program does it.  This is
# reimplemented here since some systems lndir doesn't seem to work right.
#
# As a special exception to the GNU GPL, you may use and redistribute this
# function however you would like (i.e. consider it public domain).
#
# The first parameter is the directory to symlink from.
# The second parameter is the destination directory name.
#
# e.g. if you have $from/foo and $from/bar, lndir would create $to/foo and
# $to/bar.
#
# All intervening directories will be created as needed.  In addition, you
# may safely run this function again if you only want to catch additional files
# in the source directory.
#
# Note that this function will unconditionally output the files/directories
# created, as it is meant to be a close match to lndir.
#
# RETURN VALUE: Boolean true (non-zero) if successful, Boolean false (0, "")
#               if unsuccessful.
sub safe_lndir
{
    my ($from, $to) = @_;

    # Create destination directory.
    if (not -e $to)
    {
        print "$to\n";
        if (not pretending() and not super_mkdir($to))
        {
            error ("Couldn't create directory r[$to]: b[r[$!]");
            return 0;
        }
    }

    # Create closure callback subroutine.
    my $wanted = sub {
        my $dir = $File::Find::dir;
        my $file = $File::Find::fullname;
        $dir =~ s/$from/$to/;

        # Ignore the .svn directory and files.
        return if $dir =~ m,/\.svn,;

        # Create the directory.
        if (not -e $dir)
        {
            print "$dir\n";

            if (not pretending())
            {
                super_mkdir ($dir) or croak_runtime("Couldn't create directory $dir: $!");
            }
        }

        # Symlink the file.  Check if it's a regular file because File::Find
        # has no qualms about telling you you have a file called "foo/bar"
        # before pointing out that it was really a directory.
        if (-f $file and not -e "$dir/$_")
        {
            print "$dir/$_\n";

            if (not pretending())
            {
                symlink $File::Find::fullname, "$dir/$_" or
                    croak_runtime("Couldn't create file $dir/$_: $!");
            }
        }
    };

    # Recursively descend from source dir using File::Find
    eval {
        find ({ 'wanted' => $wanted,
                'follow_fast' => 1,
                'follow_skip' => 2},
              $from);
    };

    if ($@)
    {
        error ("Unable to symlink $from to $to: $@");
        return 0;
    }

    return 1;
}

# Subroutine to delete recursively, everything under the given directory,
# unless we're in pretend mode.
#
# i.e. the effect is similar to "rm -r $arg/* $arg/.*".
#
# This assumes we're called from a separate child process.  Therefore the
# normal logging routines are /not used/, since our output will be logged
# by the parent kdesrc-build.
#
# The first parameter should be the absolute path to the directory to delete.
#
# Returns boolean true on success, boolean false on failure.
sub prune_under_directory
{
    my $dir = shift;

    print "starting delete of $dir\n";
    eval {
        remove_tree($dir, { keep_root => 1 });
    };

    if ($@)
    {
        error ("\tUnable to clean r[$dir]:\n\ty[b[$@]");
        return 0;
    }

    return 1;
}

# This function converts any 'l10n' references on the command line to return a l10n
# module with the proper build system, scm type, etc.
#
# The languages are selected using global/kde-languages (which should be used
# exclusively from the configuration file).
sub expandl10nModules
{
    my ($ctx, @modules) = @_;
    my $l10n = 'l10n-kde4';

    assert_isa($ctx, 'ksb::BuildContext');

    # Only filter if 'l10n' is actually present in list.
    my @matches = grep {$_->name() =~ /^(?:$l10n|l10n)$/} @modules;
    my @langs = split(' ', $ctx->getOption('kde-languages'));

    return @modules if (!@matches || !@langs);

    my $l10nModule;
    for my $match (@matches)
    {
        # Remove all instances of l10n.
        @modules = grep {$_->name() ne $match->name()} @modules;

        # Save l10n module if user had it in config. We only save the first
        # one encountered though.
        $l10nModule //= $match;
    }

    # No l10n module? Just create one.
    $l10nModule //= ksb::Module->new($ctx, $l10n);

    whisper ("\tAdding languages ", join(';', @langs), " to build.");

    $l10nModule->setScmType('l10n');
    my $scm = $l10nModule->scm();

    # Add all required directories to the l10n module. Its buildsystem should
    # know to skip scripts and templates.
    $scm->setLanguageDirs(qw/scripts templates/, @langs);
    $l10nModule->setBuildSystem($scm);

    push @modules, $l10nModule;
    return @modules;
}

# This subroutine checks for programs which are absolutely essential to the
# *build* process and returns false if they are not all present. Right now this
# just means qmake and cmake (although this depends on what modules are
# actually present in the build context).
#
# Pass the build context as the only parameter.
sub checkForEssentialBuildPrograms
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');

    return 1 if pretending();

    my @buildModules = $ctx->modulesInPhase('build');
    my %requiredPrograms;
    my %modulesRequiringProgram;

    foreach my $module ($ctx->modulesInPhase('build')) {
        my @progs = $module->buildSystem()->requiredPrograms();

        # Deliberately used @, since requiredPrograms can return a list.
        @requiredPrograms{@progs} = 1;

        foreach my $prog (@progs) {
            $modulesRequiringProgram{$prog} //= { };
            $modulesRequiringProgram{$prog}->{$module->name()} = 1;
        }
    }

    my $wasError = 0;
    for my $prog (keys %requiredPrograms) {
        my %requiredPackages = (
            qmake => 'Qt',
            cmake => 'CMake',
        );

        my $programPath = absPathToExecutable($prog);

        # qmake is not necessarily named 'qmake'
        if (!$programPath && $prog eq 'qmake') {
            $programPath = ksb::BuildSystem::QMake::absPathToQMake();
        }

        if (!$programPath) {
            # Don't complain about Qt if we're building it...
            if ($prog eq 'qmake' && (
                    grep { $_->buildSystemType() eq 'Qt' } (@buildModules)) ||
                    pretending()
                )
            {
                next;
            }

            $wasError = 1;
            my $reqPackage = $requiredPackages{$prog} || $prog;

            my @modulesNeeding = keys %{$modulesRequiringProgram{$prog}};
            local $, = ', '; # List separator in output

            error (<<"EOF");

Unable to find r[b[$prog]. This program is absolutely essential for building
the modules: y[@modulesNeeding].
Please ensure the development packages for
$reqPackage are installed by using your distribution's package manager.

You can also see the
http://techbase.kde.org/Getting_Started/Build/Distributions page for
information specific to your distribution (although watch for outdated
information :( ).
EOF
        }
    }

    return !$wasError;
}

# Subroutine to handle the build process.
# First parameter is a reference of a list containing the packages
# we are to build.
# If the packages are not already checked-out and/or updated, this
# subroutine WILL NOT do so for you.
#
# This subroutine assumes that the $kdesrc directory has already been
# set up.  It will create $builddir if it doesn't already exist.
#
# If $builddir/$module/.refresh-me exists, the subroutine will
# completely rebuild the module.
#
# Returns 0 for success, non-zero for failure.
sub handle_build
{
    my ($ipc, $ctx) = @_;
    my @build_done;
    my @modules = grep ($_->name() !~ /^(KDE\/)?kde-common$/, $ctx->modulesInPhase('build'));
    my $result = 0;

    # No reason to print building messages if we're not building.
    return 0 if scalar @modules == 0;

    note ("<<<  Build Process  >>>");

    # Check for absolutely essential programs now.
    if (!checkForEssentialBuildPrograms($ctx) &&
        !exists $ENV{KDESRC_BUILD_IGNORE_MISSING_PROGRAMS})
    {
        error (" r[b[*] Aborting now to save a lot of wasted time.");
        error (" y[b[*] export KDESRC_BUILD_IGNORE_MISSING_PROGRAMS=1 and re-run (perhaps with --no-src)");
        error (" r[b[*] to continue anyways. If this check was in error please report a bug against");
        error (" y[b[*] kdesrc-build at https://bugs.kde.org/");

        return 1;
    }

    # IPC queue should have a message saying whether or not to bother with the
    # build.
    $ipc->waitForStreamStart();

    my $outfile = pretending() ? undef
                               : $ctx->getLogDir() . '/build-status';

    open (STATUS_FILE, '>', $outfile // '/dev/null') or do {
        error (<<EOF);
	Unable to open output status file r[b[$outfile]
	You won't be able to use the g[--resume] switch next run.\n";
EOF
        $outfile = undef;
    };

    my $num_modules = scalar @modules;
    my $i = 1;

    while (my $module = shift @modules)
    {
        my $moduleSet = $module->moduleSet() // '';
        my $moduleName = $module->name();
        my $modOutput = "$module";

        if (debugging(ksb::Debug::WHISPER)) {
            $modOutput .= " (build system " . $module->buildSystemType() . ")"
        }

        if ($moduleSet) {
            note ("Building g[$modOutput] from g[$moduleSet] ($i/$num_modules)");
        }
        else {
            note ("Building g[$modOutput] ($i/$num_modules)");
        }

        $ctx->resetEnvironment();
        $module->setupEnvironment();

        my $start_time = time;

        # If using IPC, read in the contents of the message buffer, and wait
        # for completion of the svn update if necessary.

        my ($resultStatus, $message) = $ipc->waitForModule($module);

        given ($resultStatus) {
            when ('failed') {
                $result = 1;
                $ctx->markModulePhaseFailed('update', $module);
                print STATUS_FILE "$module: Failed on update.\n";

                # Increment failed count to track when to start bugging the
                # user to fix stuff.
                my $fail_count = $module->getPersistentOption('failure-count') // 0;
                ++$fail_count;
                $module->setPersistentOption('failure-count', $fail_count);

                error ("\tUnable to update r[$module], build canceled.");
                next;
            }
            when ('skipped') {
                # i.e. build should be skipped.
                info ("\tNo changes to source code.");
            }
            when ('success') {
                note ("\tSource update complete for g[$module]: $message");
            }
        }

        # Skip actually building a module if the user has selected to skip
        # builds when the source code was not actually updated. But, don't skip
        # if we didn't successfully build last time.
        if (!$module->getOption('build-when-unchanged') &&
            $resultStatus eq 'skipped' &&
            ($module->getPersistentOption('failure-count') // 0) == 0)
        {
            note ("\tSkipping g[$module], its source code has not changed.");
            $i++;
            next;
        }

        if ($module->build())
        {
            my $elapsed = prettify_seconds(time - $start_time);
            print STATUS_FILE "$module: Succeeded after $elapsed.\n";
            $module->setPersistentOption('last-build-rev', $module->currentScmRevision());
            $module->setPersistentOption('failure-count', 0);

            info ("\tOverall time for g[$module] was g[$elapsed].");
            push @build_done, $moduleName;
        }
        else
        {
            my $elapsed = prettify_seconds(time - $start_time);
            print STATUS_FILE "$module: Failed after $elapsed.\n";

            info ("\tOverall time for r[$module] was g[$elapsed].");
            $ctx->markModulePhaseFailed('build', $module);
            $result = 1;

            # Increment failed count to track when to start bugging the
            # user to fix stuff.

            my $fail_count = $module->getPersistentOption('failure-count') // 0;
            ++$fail_count;
            $module->setPersistentOption('failure-count', $fail_count);

            if ($module->getOption('stop-on-failure'))
            {
                note ("\n$module didn't build, stopping here.");
                return 1; # Error
            }
        }

        $i++;
    }
    continue # Happens at the end of each loop and on next
    {
        print "\n"; # Space things out
    }

    if ($outfile)
    {
        close STATUS_FILE;

        # Update the symlink in latest to point to this file.
        my $logdir = $ctx->getSubdirPath('log-dir');
        if (-l "$logdir/latest/build-status") {
            safe_unlink("$logdir/latest/build-status");
        }
        symlink($outfile, "$logdir/latest/build-status");
    }

    info ("<<<  Build Done  >>>");
    info ("\n<<<  g[PACKAGES SUCCESSFULLY BUILT]  >>>") if scalar @build_done > 0;

    if (not pretending())
    {
        # Print out results, and output to a file
        my $kdesrc = $ctx->getSourceDir();
        open BUILT_LIST, ">$kdesrc/successfully-built";
        foreach my $module (@build_done)
        {
            info ("$module");
            print BUILT_LIST "$module\n";
        }
        close BUILT_LIST;
    }
    else
    {
        # Just print out the results
        info ('g[', join ("]\ng[", @build_done), ']');
    }

    info (" "); # Add newline for aesthetics if not in quiet mode.
    return $result;
}

# Subroutine to exit the script cleanly, including removing any
# lock files created.  If a parameter is passed, it is interpreted
# as an exit code to use
sub finish
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my $exitcode = shift // 0;

    @main::atexit_subs = ();
    if (pretending() || $main::basePid != $$) {
        # Abort early if pretending or if we're not the same process
        # that was started by the user (e.g. async mode, forked pipe-opens
        exit $exitcode;
    }

    $ctx->closeLock();
    $ctx->storePersistentOptions();

    my $logdir = $ctx->getLogDir();
    note ("Your logs are saved in y[$logdir]");

    exit $exitcode;
}

# Subroutine to handle the installation process.  Simply calls
# 'make install' in the build directory.
#
# Return value is a shell-style success code (0 == success)
sub handle_install
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my @modules = @_;

    # Check all modules passed.
    map { assert_isa($_, 'ksb::Module') } @modules;

    @modules = grep { $_->buildSystem()->needsInstalled() } (@modules);
    my $result = 0;

    for my $module (@modules)
    {
        $ctx->resetEnvironment();
        $result = $module->install() || $result;

        if ($result && $module->getOption('stop-on-failure')) {
            note ("y[Stopping here].");
            return 1; # Error
        }
    }

    return $result;
}

# Subroutine to handle the installation process.  Simply calls
# 'make uninstall' in the build directory, assuming that Qt or
# CMake can actually handle it.
#
# The order of the modules is often significant, in the case of
# this function the modules are uninstalled IN THE OPPOSITE ORDER
# than passed in, to be more compatible with the rest of the code.
#
# Return value is a shell-style success code (0 == success)
sub handle_uninstall
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my @modules = @_;

    # Check all modules passed.
    map { assert_isa($_, 'ksb::Module') } @modules;

    @modules = grep { $_->buildSystem()->needsInstalled() } (@modules);
    my $result = 0;

    for my $module (reverse @modules)
    {
        $ctx->resetEnvironment();
        $result = $module->uninstall() || $result;

        if ($result && $module->getOption('stop-on-failure'))
        {
            note ("y[Stopping here].");
            return 1; # Error
        }
    }

    return $result;
}

# This subroutine is used in order to apply any module-specific filtering that
# is necessary after reading command line and rc-file options. (This is as
# opposed to phase filters, which leave each module as-is but change the phases
# they operate part of, this function could remove a module entirely from the
# build).
#
# Famously used for --resume-from and --resume-after, but more could be added
# in theory.
#
# Requires a list of "ksb::Module" type objects, and returns the list with filters
# applied. Right now the return list will be a subset of the given list, but
# it's best not to rely on that long-term.
sub applyModuleFilters
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my @moduleList = @_;

    if (!$ctx->getOption('resume-from') && !$ctx->getOption('resume-after'))
    {
        debug ("No --resume-from or --resume-after seems present.");
        return @moduleList;
    }

    if ($ctx->getOption('resume-from') && $ctx->getOption('resume-after'))
    {
        # This one's an error.
        error (<<EOF);
You specified both r[b[--resume-from] and r[b[--resume-after] but you can only
use one.
EOF

        croak_runtime("Both --resume-after and --resume-from specified.");
    }

    my $resumePoint = $ctx->getOption('resume-from') ||
                      $ctx->getOption('resume-after');

    debug ("Looking for $resumePoint for --resume-* option");

    # || 0 is a hack to force Boolean context.
    my $filterInclusive = $ctx->getOption('resume-from') || 0;
    my $found = 0;

    # If we already found our resume point, include this module. If this module
    # *is* the resume point, include it if filterInclusive is true, otherwise
    # just flag it. Module sets complicate the logic a bit, but it's basically
    # just harder in the --resume-after case where we have to leave that module
    # set before we can allow modules through the filter.
    my $filterTest = sub {
        my $moduleSet = $_->moduleSet() // '';
        if ($found) {
            return $filterInclusive || $moduleSet ne $resumePoint;
        }
        $found = $_->{'name'} eq $resumePoint || $moduleSet eq $resumePoint;
        return $found && $filterInclusive;
    };

    my @resultList = grep { &$filterTest } (@moduleList);

    if (!@resultList && @moduleList) {
        # Lost all modules somehow.
        croak_runtime("Unknown resume point $resumePoint.");
    }

    return @resultList;
}

# Exits out of kdesrc-build, executing the user's preferred shell instead.  The
# difference is that the environment variables should be as set in kdesrc-build
# instead of as read from .bashrc and friends.
#
# You should pass in the options to run the program with as a list.
#
# Meant to implement the --run command line option.
sub execute_command_line_program
{
    my ($program, @args) = @_;

    if (!$program)
    {
        error ("You need to specify a program with the --run option.");
        exit 1; # Can't use finish here.
    }

    if (($< != $>) && ($> == 0))
    {
        error ("kdesrc-build will not run a program as root unless you really are root.");
        exit 1;
    }

    debug ("Executing b[r[$program] ", join(' ', @args));

    exit 0 if pretending();

    exec $program, @args or do {
        # If we get to here, that sucks, but don't continue.
        error ("Error executing $program: $!");
        exit 1;
    };
}

# This subroutine is the monitoring process for when using IPC::Pipe.  It reads
# in all status reports from the source update process and then holds on
# to them.  When the build process is ready to read information we send what
# we have.  Otherwise we're waiting on the update process to send us something.
#
# This convoluted arrangement is required to allow the source update
# process to go from start to finish without undue interruption on it waiting
# to write out its status to the build process which is usually busy.
#
# First parameter is the IPC object to use.
#
# Returns 0 on success, non-zero on failure.
sub handle_monitoring
{
    my $ipc = shift;

    # Setup some file handle sets to use in the select() call.
    # The out ones are copies of the in ones since select() overwrites its
    # parameters.
    my ($win, $wout, $rin, $rout);
    ($win, $rin) = ("") x 2; # Get rid of undefined warnings.

    my @msgs;  # Message queue.

    # Perl uses vec() to setup the file handle sets.  Make some local
    # subroutines to make it suck less in the real code.
    sub setFdInSet($$$) {
        my ($set, $fh, $inSet) = @_;
        vec($set, fileno($fh), 1) = $inSet;
        return $set;
    }

    sub fdIsChosen($$) {
        my ($set, $fh) = @_;
        return vec($set, fileno($fh), 1) == 1;
    }

    # We will write to the build process and read from the update process.
    $win = setFdInSet($win, $ipc->{'toBuild'}, 1);
    $rin = setFdInSet($rin, $ipc->{'fromSvn'}, 1);

    # Start the loop.  We will be waiting on either $win or $rin.  Whenever
    # select() returns we must check both sets.
    for(;;)
    {
        my $numFound = select($rout = $rin, $wout = $win, undef, undef);
        my $selectErr = $!;

        if ($numFound == -1)
        {
            error ("r[mon]: Monitor IPC error: r[$selectErr]");
            return 1;
        }

        # Check for svn updates first.
        if (fdIsChosen($rout, $ipc->{'fromSvn'}))
        {
            my $msg = $ipc->receiveFromUpdater();

            # undef can be returned on EOF as well as error.  EOF means the
            # other side is presumably done.
            if (not defined $msg and not $!)
            {
                $rin = setFdInSet($rin, $ipc->{'fromSvn'}, 0);
                last; # Select no longer needed, just output to build.
            }

            # Don't check for $! first, it seems to always be set to EBADF.
            # Probably I'm screwing up the select() call?
            if (defined $msg)
            {
                push @msgs, $msg;
            }
            else
            {
                error ("r[mon]: Error reading update: r[b[$selectErr]");
                return 1;
            }
        }

        # Now check for build updates.
        if (fdIsChosen($wout, $ipc->{'toBuild'}))
        {
            # If we're here the update is still going.  If we have no messages
            # to send wait for that first.
            if (not @msgs)
            {
                my ($rout2, $numFound2);
                $numFound2 = select($rout2 = $rin, undef, undef, undef);
                $selectErr = $!;

                if ($numFound2 == -1 and $selectErr)
                {
                    error ("r[mon]: Monitor IPC error: r[$selectErr]");
                    return 1;
                }

                # Assume EOF can happen here.
                my $msg = $ipc->receiveFromUpdater();
                $selectErr = $!;
                if (not defined $msg and $selectErr)
                {
                    error ("r[mon]: Monitor IPC error, unexpected disappearance of updater.");
                    error ("r[mon]: Mysterious circumstances: r[b[$selectErr]");
                    return 1;
                }

                push @msgs, $msg if $msg;
            }

            # Send the message (if we got one).
            if (scalar @msgs and !$ipc->sendToBuilder(shift @msgs))
            {
                error ("r[mon]: Build process stopped too soon! r[$!]");
                return 1;
            }
        }
    }

    # Send all remaining messages.
    while (@msgs)
    {
        if (!$ipc->sendToBuilder(shift @msgs))
        {
            error ("r[mon]: Build process stopped too soon! r[$!]");
            return 1;
        }
    }

    return 0;
}

# This subroutine performs the update and build process asynchronously.
#
# Only one thread or process of execution will return from this procedure.
#
# The first parameter should be the IPC object to use, which must support
# concurrency.
#
# Returns 0 on success, non-zero on failure.
sub handle_async_build
{
    # The exact method for async is that two children are forked.  One child
    # is a svn update process.  The other child is a monitor process which will
    # hold status updates from the svn process so that the svn updates may
    # happen without waiting for us to be ready to read.

    my ($ipc, $ctx) = @_;

    my $svnPid = fork;
    if ($svnPid == 0)
    { # child
        $ipc->setUpdater();
        # Avoid calling close subroutines in more than one routine.
        POSIX::_exit (handle_updates ($ipc, $ctx));
    }

    # Parent
    my $monPid = fork;
    if ($monPid == 0)
    { # monitor
        $ipc->setMonitor();
        # Avoid calling close subroutines in more than one routine.
        POSIX::_exit (handle_monitoring ($ipc));
    }

    # Still the parent, let's do the build.
    $ipc->setBuilder();
    my $result = handle_build ($ipc, $ctx);

    # Exit code is in $?.
    waitpid ($svnPid, 0);
    $result = 1 if $? != 0;

    waitpid ($monPid, 0);
    $result = 1 if $? != 0;

    return $result;
}

# Returns the unique entries in the given list, original ordering is not
# maintained.
sub unique_list
{
    # Take advantage of the fact that Perl hashes don't support duplicate
    # keys by stuffing each item in our input list into a hash as a key, then
    # retrieve the keys to get the unique items.
    # Using the hash slice notation @hash{@list} is apparently a bit faster.
    return do { my %tempHash; @tempHash{@_} = (); keys %tempHash; };
}

# Returns a list of module directory IDs that must be kept due to being
# referenced from the "latest" symlink.  It should be called with the "latest"
# directory that is a standard subdirectory of the log directory.
#
# First parameter is the directory to search under for symlinks.  This
# subroutine will call itself recursively if necessary to search under the given
# directory.  Any symlinks are read to see which log directory is pointed to.
sub needed_module_logs
{
    my $logdir = shift;
    my @dirs;

    # A lexicalized var (my $foo) is required in face of recursiveness.
    opendir(my $fh, $logdir) or croak_runtime("Can't opendir $logdir: $!");
    my $dir = readdir($fh);

    while(defined $dir) {
        if (-l "$logdir/$dir") {
            my $link = readlink("$logdir/$dir");
            push @dirs, $link;
        }
        elsif ($dir !~ /^\.{1,2}$/) {
            # Skip . and .. directories (this is a great idea, trust me)
            push @dirs, needed_module_logs("$logdir/$dir");
        }
        $dir = readdir $fh;
    }

    closedir $fh;

    # Convert directory names to numeric IDs.
    @dirs = map { m/(\d{4}-\d\d-\d\d-\d\d)/ } (@dirs);
    return unique_list(@dirs);
}

# This function removes log directories from old kdesrc-build runs.  All log
# directories not referenced by $log_dir/latest somehow are made to go away.
sub cleanup_log_directory
{
    my $ctx = assert_isa(shift, 'ksb::BuildContext');
    my $logdir = $ctx->getSubdirPath('log-dir');

    return 0 if ! -e "$logdir/latest"; # Could happen for error on first run...

    # This glob relies on the date being in the specific format YYYY-MM-DD-ID
    my @dirs = bsd_glob("$logdir/????-??-??-??/", GLOB_NOSORT);
    my @needed = needed_module_logs("$logdir/latest");

    # Convert a list to a hash lookup since Perl lacks a "list-has"
    my %needed_table;
    @needed_table{@needed} = (1) x @needed;

    my $length = scalar @dirs - scalar @needed;
    if ($length > 15) { # Arbitrary man is arbitrary
        note ("Removing y[b[$length] out of g[b[$#dirs] old log directories (this may take some time)...");
    }
    elsif ($length > 0) {
        info ("Removing g[b[$length] out of g[b[$#dirs] old log directories...");
    }

    for my $dir (@dirs) {
        my ($id) = ($dir =~ m/(\d\d\d\d-\d\d-\d\d-\d\d)/);
        safe_rmtree($dir) unless $needed_table{$id};
    }
}

# Script starts.

# Adding in a way to load all the functions without running the program to
# enable some kind of automated QA testing.
if (defined caller && caller eq 'test')
{
    print "kdesrc-build being run from testing framework, BRING IT.\n";
    print "kdesrc-build is version $SCRIPT_VERSION\n";
    return 1;
}

my $ctx;
our @atexit_subs;
our $basePid = $$; # Only run exit handlers from the process with the PID we started with.

END {
    # Basically used to call the finish() handler but only when appropriate.
    foreach my $sub (@atexit_subs) {
        &$sub();
    }
}

# Use some exception handling to avoid ucky error messages
eval
{
    # preinit {{{
    # Note: Don't change the order around unless you're sure of what you're
    # doing.

    # Default to colorized output if sending to TTY
    ksb::Debug::setColorfulOutput(-t STDOUT);
    $ctx = ksb::BuildContext->new();
    my $pendingOptions = { };

    # Process --help, --install, etc. first.
    my @modules = process_arguments($ctx, $pendingOptions, @ARGV);

    # Change name and type of command line entries beginning with + to force
    # them to be XML project modules.
    foreach (@modules) {
        if (substr($_->{name}, 0, 1) eq '+') {
            debug ("Forcing ", $_->name(), " to be an XML module");
            $_->setScmType('proj');
            substr($_->{name}, 0, 1) = ''; # Remove first char
        }
    }

    my $fh = $ctx->loadRcFile();

    # If we're still here, read the options
    my @optionModules = read_options($ctx, $fh);
    close $fh;

    # Modify the options read from the rc-file to have the pending changes from
    # the command line.
    foreach my $pendingModule (keys %{$pendingOptions}) {
        my $options = ${$pendingOptions}{$pendingModule};
        my ($module) = grep { $pendingModule eq $_->name() } (@optionModules);

        if (!$module) {
            warning ("Tried to set options for unknown module b[y[$pendingModule]");
            next;
        }

        while (my ($key, $value) = each %{$options}) {
            debug ("Setting pending option $key to $value for $pendingModule");
            $module->setOption($key, $value);
        }
    }

    # Check if we're supposed to drop into an interactive shell instead.  If so,
    # here's the stop off point.

    if (my $prog = $ctx->getOption('#start-program'))
    {
        # @modules is the command line arguments to pass in this case.
        execute_command_line_program($prog, @modules);
    }

    $ctx->setupOperatingEnvironment(); # i.e. niceness, ulimits, etc.

    my $commandLineModules = scalar @modules;

    # Allow named module-sets to be given on the command line.
    if ($commandLineModules) {
        # Copy ksb::Module objects from the ones created by read_options
        # since their module-type will actually be set.
        foreach my $module (@modules) {
            my ($optionModule) = grep {$_->name() eq $module->name()} @optionModules;
            $module = $optionModule if defined $optionModule;
        }

        # Modify l10n module inline, if present.
        for (@modules) {
            if ($_->name() eq 'l10n') { $_->setScmType('l10n') }
        }

        # Filter --resume-foo first so entire module-sets can be skipped.
        # Wrap in eval to catch runtime errors
        eval { @modules = applyModuleFilters($ctx, @modules); };
        @modules = expandModuleSets(\@modules, \@optionModules);
        ksb::Module->setModuleSource('cmdline');
    }
    else {
        @modules = @optionModules;

        if ($ctx->getOption('kde-languages')) {
            my $l10nModule = ksb::Module->new($ctx, 'l10n');
            $l10nModule->setScmType('l10n');
            $l10nModule->setBuildSystem($l10nModule->scm());

            push @modules, $l10nModule;
        }

        ksb::Module->setModuleSource('config');
    }

    # Must be done before filtering so that we can filter under module-sets.
    @modules = expandXMLModules($ctx, @modules);

    # Filter --resume-foo options. This might be a second pass, but that should
    # be OK since there's nothing different going on from the first pass in that
    # event.
    @modules = applyModuleFilters($ctx, @modules);

    # Apply kde-languages, by appending needed l10n modules to the end of the
    # build.
    @modules = expandl10nModules($ctx, @modules);

    # If modules were on the command line then they are effectively forced to
    # process unless overridden by command line options as well. If phases
    # *were* overridden on the command line, then no update pass is required
    # (all modules already have correct phases)
    @modules = updateModulePhases(@modules) unless $commandLineModules;

    if (exists $ENV{KDESRC_BUILD_DUMP_CONTEXT}) {
        local $Data::Dumper::Indent = 1;
        local $Data::Dumper::Sortkeys = 1;

        # This method call dumps the first list with the variables named by the
        # second list.
        print Data::Dumper->Dump([$ctx], [qw(ctx)]);
    }

    if (!pretending() && !$ctx->takeLock())
    {
        print "$0 is already running!\n";
        exit 1; # Don't finish(), it's not our lockfile!!
    }
    else
    {
        my $curPid = $$;
        push @atexit_subs, sub { finish($ctx, 99) if $$ == $curPid };
    }
    # }}}

    # execution phase {{{
    my $time = localtime;
    info ("Script started processing at g[$time]") unless pretending();

    $ctx->loadPersistentOptions();
    my $metadataModule;

    # If we have kde-build-metadata we must process it first, ASAP.
    if (grep { $_->name() eq 'kde-build-metadata' } @modules) {
        $metadataModule = shift @modules;
        assert_isa($metadataModule->scm(), 'ksb::Updater::KDEProjectMetadata');

        eval {
            super_mkdir($metadataModule->getSourceDir());
            info ("\tDownloading KDE Project module metadata...");
            $metadataModule->scm()->updateInternal();
        };

        if ($@) {
            warning (" b[r[*] Unable to download required metadata for build process");
            warning (" b[r[*] Will attempt to press onward...");
            warning (" b[r[*] Exception message: $@");
        }
    }

    # Reorder if necessary. This involves reading some metadata so wrap in its
    # own exception handler.
    eval {
        if ($metadataModule) {
            my $dependencyFile = $metadataModule->fullpath('source') . '/dependency-data';
            open my $dependencies, '<', $dependencyFile
                or die "Unable to open $dependencyFile: $!";

            my $dependencyResolver = DependencyResolver->new();
            $dependencyResolver->readDependencyData($dependencies);

            my @reorderedModules = $dependencyResolver->resolveDependencies(@modules);

            # If we make it here no exceptions were thrown, so accept the result
            @modules = @reorderedModules;
        }
    };

    if ($@) {
        warning (" r[b[*] Problems encountered trying to sort modules into correct order:");
        warning (" r[b[*] $@");
        warning (" r[b[*] Will attempt to continue.");
    }

    # Add to global module list now that we've filtered everything.
    $ctx->addModule($_) foreach @modules;

    my $result;
    my @update_list = map { $_->name() } ($ctx->modulesInPhase('update'));
    my @build_list = map { $_->name() } ($ctx->modulesInPhase('build'));

    debug ("Update list is ", join (', ', @update_list));
    debug ("Build list is ", join (', ', @build_list));

    # Do some necessary adjusting. Right now this is used for supporting
    # the command-line option shortcut to where you can enter e.g.
    # kdelibs/khtml, and the script will only try to update that part of
    # the module.
    # munge_lists(); # TODO: Unbreak my munge, say you'll work again.

    if ($run_mode eq 'build')
    {
        # No packages to install, we're in build mode

        # What we're going to do is fork another child to perform the svn
        # updates while we build.  Setup for this first by initializing some
        # shared memory.
        my $ipc = 0;

        if ($ctx->getOption('async'))
        {
            $ipc = ksb::IPC::Pipe->new();
        }

        if (!$ipc)
        {
            $ipc = ksb::IPC::Null->new();
            whisper ("Using no IPC mechanism\n");

            $result = handle_updates ($ipc, $ctx);
            $result = handle_build ($ipc, $ctx) || $result;
        }
        else
        {
            $result = handle_async_build ($ipc, $ctx);
        }
    }
    elsif ($run_mode eq 'install')
    {
        # Installation mode
        my @installList = $ctx->modulesInPhase('install');

        $result = handle_install ($ctx, @installList);
    }
    elsif ($run_mode eq 'uninstall')
    {
        my @uninstallList = $ctx->modulesInPhase('uninstall');

        # Make handle_uninstall handle in right order (it reverses the order
        # so that the first module uninstalled is the last one installed).
        if (ksb::Module->moduleSource() eq 'cmdline') {
            @uninstallList = reverse @uninstallList;
        }

        $result = handle_uninstall ($ctx, @uninstallList);
    }

    cleanup_log_directory($ctx) if $ctx->getOption('purge-old-logs');
    output_failed_module_lists($ctx);
    installCustomSessionDriver($ctx) if $ctx->getOption('install-session-driver');

    $time = localtime;
    my $color = '';
    $color = 'r[' if $result;

    info ("${color}Script finished processing at g[$time]") unless pretending();

    @atexit_subs = (); # Clear exit handlers
    finish($ctx, $result);

    # }}}
};

if (my $err = $@)
{
    if (ref $err && $err->isa('BuildException')) {
        print $err->{'exception_type'}, " error: ", $err->{'message'}, "\n";
        print "\tCan't continue, so stopping now.\n";

        if ($err->{'exception_type'} eq 'Internal') {
            print "\nPlease submit a bug against kdesrc-build on http://bugs.kde.org/\n"
        }
    }
    else {
        # We encountered an error.
        print "Encountered an error in the execution of the script.\n";
        print "The error reported was $err\n";
        print "Please submit a bug against kdesrc-build on http://bugs.kde.org/\n";
    }

    exit 99;
}

# vim: set et sw=4 ts=4 fdm=marker:
